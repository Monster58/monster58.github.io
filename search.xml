<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2019%2F05%2F15%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常见命令1234567hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令12hexo s -g #生成并本地预览hexo d -g #生成并上传]]></content>
  </entry>
  <entry>
    <title><![CDATA[Event Loop]]></title>
    <url>%2F2019%2F03%2F23%2FEvent-Loop%2F</url>
    <content type="text"><![CDATA[一次弄懂Event Loop（彻底解决此类面试问题） 转载自： 一次弄懂Event Loop 作者： 光光同学 出处： 掘金 前言Event Loop即时间循环，是指浏览器或Node的一种解决JavaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。 为什么要弄懂Event Loop 是要增加自己技术的深度，也就是懂的JavaScript的运行机制。 现在前端领域各种技术层出不穷，掌握底层原理可以让自己以不变应万变。 堆、栈、队列 堆（Heep）堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种为最大堆，一种为最小堆，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 堆是线性数据结构，相当于一堆数组，有唯一后继。 如最大堆 栈（Stack）栈在计算机科学中是限定仅在表尾进行插入或操作的线性表。栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。 栈是只能在某一端插入和删除的特殊线性表。 队列（Queue）特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。 进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素是，称为空队列。 队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO-first in first out） Event Loop在JavaScript中，人物被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask）。 MacroTask（宏任务）script全部代码、setTimeout、setInterval、setTmmediate（浏览器暂时不支持，只有IE10支持）、I/O、UI Rendering。 MicroTask（微任务）Process.nextTick（Node独有）、Promise、Object.observe（废弃）、MutationObserver（具体使用方法查看这里） 浏览器中的Event LoopJavaScript有一个main thread主线程和call-stack调用栈（执行栈），所有的任务都会被放到调用栈等待主线程执行。 js调用栈js调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移除，知道站内被清空。 同步任务和异步任务JavaScript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果之后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 任务队列Task Queue，即队列，是一种先进先出的的一种数据结构。 事件循环的进程模型 选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask)的执行步骤。 将事件循环中的任务设置为已选择任务。 执行任务。 将事件循环中当前运行任务设置为null 将已经运行完成的任务从任务队列中删除。 microtasks步骤： 进入microtask检查点 更新界面渲染。 返回第一步。 执行进入microtask检查点时，用户代理会执行以下步骤： 设置microtask检查点标志为true。 当事件循环microtask执行不为空时： 选择一个最先进入的microtask队列的microtask，将事件循环的microtask为null，移出microtask中的microtask。 清理IndexDB事务 设置进入microtask检查点的标志为false。 图片理解： 执行栈在执行完同步任务后，查看执行栈是否为空，如果执行栈为空，就会执行task（宏任务），每次宏任务执行完毕后，检查微任务（microTask）队列是否为空，如果不为空的话，会按照先入先出的规则全部执行完微任务（microTask），设置微任务（microTask）队列为null，然后再执行宏任务，如此循环。 例子：12345678910console.log('script start');setTimeout(function()&#123; console.log('setTimeout');&#125;,0);Promise.resolve().then(function()&#123; console.log('promise1');&#125;).then(function()&#123; console.log('promise2');&#125;);console.log('script end'); 首先我们划分为几个分类： 第一次执行： 1234Task: run script、 setTimeout callbackMicrotasks: Promise thenJS stack: scriptLog: script start、script end。 执行同步代码，将宏任务（Task）和微任务（Microtasks）划分到各自队列中。 第二次执行： 1234Task: run script、setTimeout callbackMicrotasks: Promise2 thenJS stack: Promise2 callbackLog: script start、script end、promise1、promise2 执行宏任务后，检测到微任务（Microtasks）队列中不为空，执行promise1，执行完成promise1后，调用promise2.then，放入微任务（Microtasks）队列中，在执行promise2.then。 第三次执行： 1234Tasks: setTimeout callbackMicrotasks: JS stack: setTimeout callbackLog: scriptstart、script end、promise1、promise2、setTimeout 当微任务（Microtasks）队列中为空时，执行宏任务（tasks），执行setTimeout callback，打印日志。 第四次执行： 1234Tasks: setTimeout callbackMicrotasks:JS stack:Log: script start、script end、promise1、promise2、setTimeout 清空Tasks队列和JS stack]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript运行机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题收集]]></title>
    <url>%2F2019%2F03%2F23%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[[TOC] CSS 怎么实现三列布局（左侧和右侧宽度固定，中间自适应） 该问题主要是想了解面试者的思维是否有局限性，实现该布局是一个比较常见并且方法很多的一种布局方式，并且可以引导面试者一步一步回答CSS相关的基础问题。 绝对定位+中间版块不给宽度 两侧浮动+中间自动撑开（使用calc动态计算宽度，设置对应宽度的margin flex，左右设置flex-basis，中间设置flex-grow 1.1 flex具体是怎么实现三列布局的（左侧和右侧的宽度是怎么设置的，中间自适应使用的是哪个属性） flex设置宽度和宽度自适应应该算是flex的最基本用法。 ​ 1.2 设置为flex属性之后，子元素的哪些属性会失效 ​ float、clear和vertical-align ​ 1.3 float/绝对定位怎么实现中间宽度自适应 移动端开发rem布局的原理（rem单位换算） 有没有自己写过组件 3.1 怎么实现样式的继承和复用 3.2 你平时都是怎么管理自己的CSS base.css common.css page.css 对应都存放哪些内容 3.3 你平时都是使用sass、less、stylesded的哪些功能，sass的计算属性对页面性能有影响吗？ 如何在页面画一个圆 SVG CANVAS css border-radius background map+area 直接放一张圆形图片 4.1 如何在页面画一个椭圆 ​ 12345678910&lt;style&gt; .sector &#123; width: 0; height: 0; border-width: 50px; border-color: #foo transparent transparent; border-style: solid; border-radius: 50px; &#125;&lt;/style&gt; 4.2 如果圆边界模糊，有什么办法去锯齿 JS JS基本数据类型 Boolean Null Undefinde Number String Symbol（ECMAScript6） Object ES5的五种数据类型和ES6的Symbol都是原始数据类型，表示独一无二的值。Object为引用类型，也包括数组、函数 1.2 原始数据类型和引用类型的区别 ​ 在内存中存储的方式不同，原始数据类型在内存中是栈存储，引用类型是堆存储，栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。 ​ 在内存中存储方式的不同导致了原始数据类型不可变，原始数据类型和引用数据类型做赋值操作一个是传值一个是传址 1.3 深拷贝和浅拷贝的区别 1.4 怎么实现浅拷贝 ES6: Object.assign() 展开运算符... 自己封装函数实现 1.5 怎么实现深拷贝 JSON.parse()(如果里面有function和undefined则不可用) lodash 自己封装 1.6 null和undefined的差异 ​ 相同点： 在if判断语句中，值都默认为false 大体上两者都代表无，具体看差异 null转为数字类型为0，而undefined转为数字类型为NaN（Not a Number) undefined是代表调用一个值而该值没有赋值，这时候默认为undefined null是一个特殊的对象，最为常见的用法就是当做一个参数传入（说明该参数不是对象） 设置为null的变量或者对象都会被内存收集器回收 实现给数字添加千分位符的方法 正则表达式： &quot;12345678&quot;.replace(/(\d)(?=(?:\d{3})+$)/g,&#39;$1,&#39;) 字符串分析，循环，在三位加’’,’’ 数字分析，取到整数部分，%1000操作，然后加逗号，拼接字符串(12345678).toLocaleString(&quot;en-US&quot;) =&gt; &quot;12,345,678&quot; 面向对象三大要素 封装 继承 多态 3.1 简单说明面向对象和面向过程的区别 面向对象就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用。 面向对象就是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在解决问题的步骤中的行为。 面向对象： 狗.吃（屎） 面向过程： 吃.（狗.屎） 3.2 怎么实现封装和继承 3.3 一句话概述什么是闭包 一句话概括什么是promise The Promise object is used for asynchronous computations. A Promise represents a single asynchronous operation that hasn’t completed yet, but is expected in the future. Prommise对象用于异步操作，它表示一个尚未完成且预计在未来完成的异步操作。 计算机相关 比较HTML XML XHTML 和 JSON 我们最熟悉的就是HTML（Hyper Text Markup Language/超文本标记语言），用来描述和定义网络内容的标记语言，超文本的意思是说，除了能标记文本，还能标记图片，视频，链接等其他内容。 XML（Extensible Markup Language/可扩展标记语言），表现就是给一堆文档加上标签，说明里面的数据是什么意思，方便存储，传输，分享数据。和HTML标签的区别就是HTML的标签就是预定义的，XML是可扩展的 XHTML（Extensible Hypertext Markup Language/可扩展超文本标记语言）其实就是HTML的严格语法形式，约定了属性名必须小写，空元素必须关闭，元素名小写，属性名必须加引号，布尔类型必须加属性值 JSON （JavaScript Object Notation）比较轻量级的数据交换格式，由键值对组成，数据格式比较简单，易于读写，格式都是压缩的，占用带宽小。 概述输入一个url到网页呈现的过程 DNS解析的详细过程 概述http的缓存控制（http2与相关缓存控制） 简述三次握手 页面加载白屏的原因有哪些，以及如何监控白屏时间，如何优化 script标签的属性有哪些 script标签的defer和async标签的作用与区别 script intergrity的作用 你所接触的前端领域的通讯有哪些 前端和后端 前端和移动端 前端父页面和iframe之间 浏览器各个tab之间 web workers线程通信 vue父子组件 10.1 通讯的要点和目的 要点： 1. 发送者和请求者 2. 传输媒介 3. 传输的数据 4. 传输格式（协议） 目的： 1. 同步数据 2. 传递指令（执行的方法） 框架 三大框架解决了传统JQ开发的哪些问题 使前端不用再操纵DOM，数据驱动，通过数据的改变直接改变DOM 1.1 Vue2.0怎么实现双向绑定的 1.2 Vue3.0怎么实现双向绑定的 1.3 Object.defineProperty()和proxy的区别 1.4 你使用过哪些Vue/React全家桶，分别解决了什么问题 1.5 Vue hash路由和history路由的区别 1.6 Vue计算属性和watch在什么场景下使用 1.7 Vue中的nexttick实现的原理 掘金收集 摘自：https://juejin.im/post/5ce4171ff265da1bd04eb4f3#heading-10 web前置知识 从url输入到页面展示背后发生了什么事？ 浏览器根据请求的URL交给DNS域名解析，找到真实的IP，向服务器发送请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML，JS, CSS 等）； 浏览器对加载到的资源（HTML, JS, CSS 等）进行语法解析，建立对应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 一次完整的HTTP事务是怎样一个过程？ 域名解析 发起TCP的三次握手； 建立TCP连接后发起http请求； 服务端响应http请求，浏览器得到html代码； 浏览器解析html代码，并请求html代码中的资源； 浏览器对页面进行渲染并呈现给用户。 浏览器是如何渲染页面的？ 浏览器页面渲染流程： 浏览器从HTTP服务器获取html文档，到呈现页面给用户，会经过以下几个步骤： 解析文档构建DOM树 浏览器的解析内容可以分为三个部分： HTML/XHTML/SVG：解析这三种文件后，会生成DOM树（DOM TREE)； CSS：解析样式表，生成CSS规则树 JavaScript：解析脚本，通过DOM API和CSSOM API操作DOM Tree和CSS Rule Tree，与用户进行交互。 以上三类文件的执行顺序会根据其在文档中的位置及其标签属性的不同而又异同。 构建渲染树 解析文档完成后，浏览器引擎会将CSS Rule Tree附着到DOM Tree上，并根据DOM Tree和CSS Rule Tree构造Rendering Tree（渲染树） 此处需要注意： Render Tree和DOM Tree的区别在于，类似Head或display：none之类的东西不会放在渲染树中； 将CSS Rule Tree匹配到DOM Tree需要解析CSS的选择器，为了提高该过程的性能，DOM树应该尽量小，CSS Selector应该尽量使用id和class，避免过度层叠。 布局与绘制渲染树 解析position，overflow，z-index等等属性，计算每个渲染树节点的位置和大小，此过程被称为reflow。最后调用操作系统的Native GUI API完成绘制（repain）。 注意： 渲染树的节点，在Gecko中成为frame，而在webkit中称为renderer 浏览器的内核有哪些？分别有什么代表的浏览器？ Trident内核：IE。 Gecko内核：Firefox。 Webkit内核：safari，曾经的chrome Presto内核：Opera，Presto是由Opera Software开发的浏览器排版引擎，它是世界上公认最快的渲染速度的引擎。在13年之后，Opera宣布加入谷歌阵营，弃用了Presto。 Blink内核：由Google和Opera Software开发的浏览器排版引擎，2013年4月发布。现在Chrome内核是Blink。谷歌还开发了自己的JS引擎，V8，使JS运行速度极大地提高了。 刷新页面，js请求一般会有哪些地方有缓存处理？ DNS缓存：短时间内多次访问某个网站，在限定时间内，不用多次访问DNS服务器； CDN缓存：内容分发网络（人们可以在就近的代售点取火车票，不用非得去火车站去排队）； 浏览器缓存：浏览器在用户磁盘上对最新请求过的文档进行了存储； 服务器缓存：将需要频繁访问的Web页面和对象保存在离用户更近的系统中，当再次访问这些对象的时候加快了速度。 HTML DOCTYPE有什么作用？怎么写？ doctype标签是一种标准通用标记语言的文档类型声明，他的目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义(DTD)来解析文档。 每个页面都要从doctype开始，他为浏览器指定这个页面的文档类型，以便浏览器更正确的显示HTML。只要按照&lt;!DOCTYPE html&gt;这样的格式和位置写，那么浏览器就会认为你在使用标准HTML。 列出常见的标签，并简单介绍这些标签用在什么场景？ 如果是标题，就用&lt;h1&gt;-&lt;h6&gt;; 如果是一段话，就用&lt;p&gt;； 如果不知道他是什么，如果能占一行，就用&lt;div&gt; 如果没有一行，就一个小小的位置，就用&lt;span&gt; 如果是可点击的就用一个&lt;a&gt;链接； 无序列表&lt;ul&gt;有序列表&lt;ol&gt; 表格：&lt;table&gt; 输入框：&lt;input&gt; title属性和alt属性分别有什么作用？ title属性有一个很好的用途：即为链接添加描述性文字，特别是当链接本身并不是十分清楚的表达链接的目的。 这样就使得访问者知道哪些链接将会带他们到什么地方，他们就不会加载一个可能完全不感兴趣的页面。 另外一个潜在的应用就是为图像提供额外的说明信息，比如日期或者其他的非本质的信息。 alt这个属性主要是为了规避例如：因网络差，硬件设备限制等外部因素，我们的浏览器不能很好的显示出图像，那alt后边的文本将会取代图像告诉用户这里会是什么东西。 1234&lt;a href="这里写链接地址“ title="Oli的前端一万小时"&gt;知乎-oliver&lt;/a&gt;&lt;!-- 注释：这里的 title 属性，作用就是：当我们把鼠标停在 oliver 上时，会弹出一个文本框：Oli-Zhao的前端一万小时。 --&gt; data-属性的作用？ 这个是H5新增的为前端开发者提供自定义的属性，这些属性集可以通过对象的dataset属性获取； 不支持该属性的浏览器可以通过getAttribute方法获取。 需要注意的是：data-之后的已连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。所有主流浏览器都支持data-*属性。 即：当没有合适的属性和元素时，自定义的data属性是能够存储页面或App的私有的自定义数据。 &lt;img&gt;的title和alt有什么区别？ title：当鼠标移动到元素上的时候显示； alt是&lt;img&gt;的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的的可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。 WEB标准以及W3C标准是什么？ 标签闭合、标签小写、不乱嵌套、使用外链css和js、结构行为样式的分离。 doctype作用？严格模式与混杂模式如何区分？他们有何意义？ &lt;DOCTYPE&gt;声明位于文档中的最前面，告知浏览器的解析器用什么文档类型规范来解析这个文档。 严格模式的排版和JS运作模式是以该浏览器支持的最高标准运行。 在混杂模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。 DOCTYPE不存在或者格式不正确会导致文档以混杂模式呈现。 HTML全局属性（global attribute）有哪些？ class：为元素设置类标识； data-*：为元素增加自定义属性； draggable：设置元素是否可拖拽； id： 元素id，文档内唯一； lang：元素内容的语言； style：行内css样式； title：元素相关的建议信息。 meta有哪些常见的值？ 指定文档编码： &lt;meta chartset=&quot;UTF-8&quot;&gt; 适配移动端页面： &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, inital-scale=1.0,mmaximum-scale=1.0, minimum-scale=1.0&quot;&gt; 设置referer &lt;meta name=&quot;referer&quot; content=&quot;never&quot; 添加页面描述： &lt;meta name=&quot;description&quot; content=&quot;注册即代表你同意《知乎协议》注册机构号......&quot; 如何在html页面上展示&lt;div&gt;&lt;/div&gt;这几个字符？ &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt; 你是如何理解HTML语义化的？ 用正确的标签做正确的事情！ html语义化就是让页面内容结构化，便于对浏览器、搜索引擎解析； 在没有样式css的情况下也可以以一种文档格式显示，并且是容易阅读的； 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于SEO； 便于理解和维护； 比如： 标签可以用&lt;h1&gt;-&lt;h6&gt;； 边栏用&lt;aside&gt;； 头部用&lt;header&gt;; 主体内容用&lt;main&gt;； 页脚用&lt;footer&gt;； 等等。 前端需要注意哪些SEO？ 合理的title、description、keyworlds： 搜索对这三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过两次，而且要靠前，不同页面title要有所不同； description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面的description有所不同； keywords列举出重要关键词即可。 语义化html代码，符合w3c规范：语义化代码让搜索引擎容易理解网页 重要内容html代码放在最前：搜索引擎抓取html顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取。 重要内容不用js输出：爬虫不会执行js获取内容。 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt。 提高网站速度：网站速度是搜索引擎排序的一个重要指标。 你对网页标准和 W3C 重要性的理解？ 网页标准和标准制定机构都是为了能让 Web 发展的更健康，开发者遵循统一的标准，降低开发难度，开发成本，SEO 也会更好做，也不会因为滥用代码导致各种 bug、安全问题，最终提高网站易用性。 post和get方式提交数据有什么区别？ get 本质上是一个URL的拼接，即把所有参数拼接到一起，形成一个新的URL。当点“提交”按钮的时候，浏览器发生以下事情： 首先，把input里type=text拿出来得到里面的内容，里面的内容就是我们输入的文字、密码等； 然后把input里的name拿出来：(username/password)； 最后，username=填写的名字、password=输入的密码等，让后把他拼成一个URL。如：（localhost:8080/abc?username=admin&amp;password=1234)​ post URL不会发生变化，他不像get那样URL会变成参数的拼接然后传输给后台。 但用户填写的数据依然会通过浏览器传输给后台（相对get老说更加的安全），且较之get，他的URL字符串长度不会因为浏览器地址栏字符长度所限制（而get，如果参数很多导致字符过长，则会被浏览器截断）。 什么时候选get/post get：往往是向后台要数据的时候用。比如向后台查论文，查数据。 post：用于向后台发送数据。 input里，name有什么作用？ 绝大多数表单元素都需要一个名字，相当于用户输入数据的一个标识符。后台服务器脚本将使用这个元素名，并提取里面的数据。 在input中，name具有很重要的作用，在数据提交到后台后，name属性可以明确的反映出每项信息是属于什么属性，如果没有name属性，数据将会非常混乱。 label有什么作用？如何使用？ label for是为了给一个input输入框前面加上可点击的说明文字；点击文字输入框即可获取焦点。 正常情况下，只能点击输入框才能获得焦点，点击文字是没有效果的。而当为input添加一个id，在label的for属性中添加这个id，当点击文字时输入框就会获得焦点。（注意：有for就必须有一个id） radio如何分组？ &lt;input type=&quot;radio&quot; name=&quot;&quot; id=&quot;&quot;&gt;单选按钮，如果要给radio分组，设置不同的name属性即可分组，同一name值属于同一组。 type=hidden隐藏域有什么作用？举例说明。 暂存一些信息。比如在&lt;input type=&quot;hidden&quot; name=&quot;_&quot; value=&quot;_&quot;&gt;里边埋了一个值，下次我们要用的时候，就直接可以定位到这个元素去获取它的值，获取到后就可以用了，但用户什么都不知道； 由于可以暂存信息，那么在针对 csrf 攻击使用一些安全策略时，可以用到这个功能。 举例： 比如打开一个页面，实际这个页面是写好的模板，然后后端往里边填充数据，填充好后让你看得到。 换句话说，这个页面是后端处理后得到的页面。那假如说，后端在渲染这个页面给我们时（返回给浏览器之前），他就通过这种方式在这里加上这个值—— &lt;input type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;123456oliver&quot;&gt;，他把这个东西写好后发给你，发给你之后，你看到的页面表面上没什么特别的变化，可实际上有一个点已经埋下了—— name=&quot;csrf&quot; value=&quot;123456oliver&quot;。 接下来，用户该干什么还是继续干，填写用户名、密码等，填写完后点击“提交”。当用户点击“提交”按钮的时候，用户所填写的所有信息都会提交给后台，同时会提交 &lt;input type=&quot;hidden&quot; name=&quot;csrf&quot; value=&quot;123456oliver&quot;&gt;里的这个值csrf=123456oliver。 提交给后台后，后台就可以做个“校验”，看看这个值对不对，如果这个值是对的，那你用户的提交是安全的。 假如说没有这样一个参数、接口，那任何人都可以伪造一个这样的页面。比如说他知道我们的请求地址（ action 的值），就可以用 method 发送一个 get/post 请求，把所有的参数都发进去，那就相当于修改了数据库。 但如果我们有这个值——csrf=123456oliver，而他没有这样一个值，或得到的值是错的，那他即使发送了这些数据，服务器也是不认可的。 只有当他发的这个值是对的，才能说明他有这个权限，表示他是一个合法的用户。这样就可以阻止 csrf 攻击。 CSRF 攻击是什么？如何防范？ 1. 是什么： CSRF（Cross-site request forgery），中文名称：跨站请求伪造。攻击者盗用了你的身份，以你的名义发送恶意请求。 CSRF 能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……造成的问题包括：个人隐私泄露以及财产安全。例如通过 QQ 等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使 Web 应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。 **2. 如何防范：** 采用 anti-csrf-token 方案。 ① 服务端在收到路由请求时，生成一个随机数，在渲染请求页面时把随机数埋入页面（一般埋入 form 表单内，`&lt;input type=&quot;hidden&quot; name=&quot;_csrf_token&quot; value=&quot;xxxx&quot;&gt;`）； ② 服务端设置 setCookie，把该随机数作为 cookie 或者 session 种入用户浏览器； ③ 当用户发送 GET 或者 POST 请求时带上`_csrf_token`参数（对于 Form 表单直接提交即可，因为会自动把当前表单内所有的 input 提交给后台，包括`_csrf_token`）； ④ 后台在接受到请求后解析请求的cookie获取`_csrf_token`的值，然后和用户请求提交的`_csrf_token`做个比较，如果相等表示请求是合法的。 网页验证码是干嘛的？是为了解决什么安全问题？ 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水。 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 常见 web 安全及防护原理？ SQL 注入原理 通过把 SQL 命令插入到 Web 表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的 SQL 命令。 总的来说有以下几点： - 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双 - 进行转换等。 - 永远不要使用动态拼装 SQL，可以使用参数化的 SQL 或者直接使用存储过程进行数据查询存取。 - 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 - 不要把机密信息明文存放，请加密或者 hash 掉密码和敏感的信息。 **XSS 原理及防范：** XSS（cross-site scripting攻击）指的是攻击者往 Web 页面里插入恶意 html 标签或者 javascript 代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取 cookie 中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 **XSS 防范方法**： - 首先代码里对用户输入的地方和变量都需要仔细检查长度和对 “&lt;”，“&gt;”，“;”，“’” 等字符做过滤； - 其次任何内容写到页面之前都必须加以 encode，避免不小心把 html tag 弄出来。这一个层面做好，至少可以堵住超过一半的 XSS 攻击。 **XSS 与 CSRF 有什么区别吗？** XSS 是获取信息，不需要提前知道其他用户页面的代码和数据包。 CSRF 是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次 CSRF 攻击，受害者必须依次完成两个步骤： 1. 登录受信任网站 A，并在本地生成 Cookie。 2. 在不登出 A 的情况下，访问危险网站 B。 **CSRF 的防御**： 服务端的 CSRF 方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过验证码的方法。]]></content>
      <categories>
        <category>前端面试题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MintUI的使用]]></title>
    <url>%2F2019%2F03%2F18%2FMintUI%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[官方文档 GitHub 导入方式 全部导入 按需导入 使用MUI代码片段 注意：MUI不同于Mint-UI，MUI只是开发出来的一套好用的代码片段，里面提供了配套的样式，配套的HTML代码段，类似于Bootstrap；而Mint-ui是真正的组件库，是使用Vue技术封装出来的成套的组件，可以无缝的和VUE项目集成开发； 因此从体验上来说，Mint-ui更好，而MUI和Bootstrap类似； 理论上任何项目都可以使用MUI或Bootstrap，但是Mint-ui只适用于Vue项目； 官网首页 文档地址 MUI不能通过npm下载，只能在github手动下载！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue 移动端组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack入门]]></title>
    <url>%2F2019%2F03%2F17%2Fwebpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[webpack中文文档webpack官网 了解webpack相关什么是webpack webpack是一个模块打包器（bundler） 在webpack看来，前端所有的资源文件（js/json/css/img/less/…）都会作为模块处理 它将根据模块的依赖关系进行静态分析，生成对应的静态资源理解loader webpack本身只能加载JS/JSON模块，如果要加载其他类型的文件（模块），就需要使用对应的loader进行转换/加载 loader本身也是运行在node.js环境中的javascript模块 它本身是个函数，接受源文件作为参数，返回转换得结果 loader一般以xxx-loader的方式命名，xxx代表了这个loader需要做的转换功能，比如json-loader配置文件（默认） webpack.config.js是一个node模块，返回一个json格式的配置信息对象插件 插件可以完成一些loader不能完成的功能。 插件的使用一般是在webpack的配置信息plugins选项中指定。 CleanWebpackPlugin： 自动生成HTML文件 UgligyJSPlugin: 压缩js文件安装webpack12345# 全局安装# 不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。npm install webpack -g# 局部安装npm install webpack --save-dev 如果你使用 webpack 4+ 版本，你还需要安装 CLI。 1npm install --save-dev webpack-cli 编译打包应用 创建入口src/js/entry.js 创建主页面dist/index.html &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 编译js 1webpack src/js/entry.js dist/bundle.js 添加js/json文件 创建第二个js: src/js/math.js 1234567export function square(x) &#123; return x * x;&#125;export function cube(x) &#123; return x * x * x;&#125; 创建json文件: src/json/data.json 1234&#123; "name": "Tom", "age": 12&#125; 更新入口js : entry.js 123456import &#123;cube&#125; from './math'import data from '../json/data.json'//注意data会自动被转换为原生的js对象或者数组document.write("entry.js is work &lt;br/&gt;");document.write(cube(2) + '&lt;br/&gt;');document.write(JSON.stringify(data) + '&lt;br/&gt;') 编译js: 1webpack src/js/entry.js dist/bundle.js 使用webpack配置文件 根目录下创建webpack.config.js文件 123456789const path = require('path'); //path内置的模块，用来设置路径。module.exports = &#123; entry: './src/js/entry.js', // 入口文件 output: &#123; // 输出配置 filename: 'bundle.js', // 输出文件名 path: path.resolve(__dirname, 'dist') //输出文件路径配置 &#125;&#125;; 配置npm命令package.json123"scripts": &#123; "build": "webpack" &#125;, 打包应用1npm run build 打包css和图片文件 安装样式的loader 123npm install css-loader style-loader --save-devnpm install file-loader url-loader --save-dev#补充：url-loader是对象file-loader的上层封装，使用时需配合file-loader使用。 大图无法打包到entry.js文件中，index.html不在生成资源目录下。页面加载图片会在所在目录位置查找，导致页面加载图片时候大图路径无法找到解决办法： 使用publicPath : dist/js/&#39;//设置为index.html提供资源的路径,设置完后找所有的资源都会去当前目录下找。 将index.html放在dist/js/也可以解决。12345module: &#123; //用来配置第三方loader模块的 rules: &#123; //文件的匹配规则 &#123;test: /\.css$/, use: ['style-loader', 'css-loader']&#125;//处理css文件的规则 &#125;&#125; 注意： use表示使用哪些模块来处理test所匹配到的文件；use中相关loader模块的调用顺序 是从后向前调用的； url-loader的使用 webpack无法处理css文件中的url地址，不管是图片还是字体库； url-loader默认会把图片转为base64格式，并且为避免图片重名会对对图片进行重命名 1&#123; test: /\.(jpg|png|gif|bmp|jpeg)$/, use: 'url-loader?limit=7631&amp;name=[hash:8]-[name].[ext]'&#125; 以浏览器地址栏传参的形式为url-loader传入参数，limit给定的值是图片的大小，单位是字节byte，如果引用的图片大于或等于给定的limit值，则不会转为base64格式的字符串，如果图片小于给定的limit值，则会转为base64字符串； name设定文件名的格式，[hash：8]为hash值的前八位，-表示以-进行拼接,[name]表示原名字，[ext]表示已原后缀名结尾； 打包less1npm i less less-loader -D 1&#123;test: /\.less/, use: ['style-loader', 'css-loader', 'less-loader']&#125; 自动编译打包 利用webpack开发服务期工具webpack-dev-server 下载 1npm install --save-dev webpack-dev-server webpack.config.js配置 123devServer:&#123; contentBase: './dist'&#125;, package.json配置 1"start": "webpack-dev-server --open" 编译打包应用并运行 1npm start 使用webpack插件 由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改index.html中的script标签的src属性，所以推荐使用html-webpack-plugin插件配置启动页面； 常用的插件 使用html-webpack-plugin根据模板html生成引入script的页面 使用clean-webpack-plugin清除dist文件夹 下载 1npm install --save-dev html-webpack-plugin clean-webpack-plugin webpack.config.js配置 123456const HtmlWebpackPlugin = require('html-webpack-plugin'); //自动生成html文件的插件const CleanWebpackPlugin = require('clean-webpack-plugin'); //清除之前打包的文件 plugins: [ new HtmlWebpackPlugin(&#123;template: './index.html'&#125;), new CleanWebpackPlugin(['dist']),] 打包运行项目 12npm run buildnpm start]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端构建工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是MVVM]]></title>
    <url>%2F2019%2F03%2F17%2F%E4%BB%80%E4%B9%88%E6%98%AFMVVM%2F</url>
    <content type="text"><![CDATA[特点： 针对具有复杂交互逻辑的前端应用 提供基础的架构抽象 通过Ajax数据持久化，保证前端用户体验市面上几个主流的MVVM框架 AngularJS reactJS VueJS数据驱动数据响应原理数据（model）改变驱动视图（view）自动更新组件化扩展HTML元素，封装可重用的代码组件设计原则 页面上每个独立的可视/可交互区域视为一个组件 每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护 页面不过是组件的容器，组件可以嵌套自由组合形成完整的页面]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看npm全局安装的模块]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%9F%A5%E7%9C%8Bnpm%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E7%9A%84%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1npm list -g --depth 0]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nrm的安装使用]]></title>
    <url>%2F2019%2F03%2F02%2Fnrm%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[提供了一些常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址； 什么是镜像： 原来包刚一开始只存在与国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内创建一个和官网完全一样的NPM服务器，只不过数据都是从国外拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前可用的镜像源地址已经所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址；]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueJS笔记]]></title>
    <url>%2F2019%2F01%2F19%2FVueJS%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[@[toc] Vue.js中文官网 单页面应用程序 Single Page Application简称SPA 网站交互及开发方式经典的多页面 例如：京东、淘宝等电商网站。 前后端融合，开发维护效率低下 用户体验一般，点击刷新跳转，等待时间过长 每个页面都需要重新加载渲染，速度慢 有利于SEO搜索引擎搜索 现代式的单页面 例如：网易云音乐、coding等。单页面应用程序的最主要的目的是为了让前后端分离，用户体验是次要的。 前后端分离，开发效率高，可维护性好 服务端不关心页面，只关心数据 客户端不关心数据库及数据操作，只关心通过接口那数据和服务端做交互，处理页面。 用户体验好，就像一个原生的客户端软件一样使用 只需要加载渲染局部视图即可，不需要整页刷新 单页面应用开发技术复杂，所以诞生了一堆开发框架 AngularJS ReactJS VueJS 单页面技术不是特别成熟（无法兼容到低版本浏览器） 但是现在除了一些电商网站，其实已经很少有系统需要去兼容低版本浏览器 大部分都是ie9以上 单页面由于数据都是异步加载过来的，所以不利于搜索引擎搜索。 手机WEB页面 管理系统 前端三大开发框架 单页开发其实是比较复杂的，需要有一定的技术支撑所以就有了我们现在需要学习的三大框架 Angular 09年诞生 Google 他的目的就是让我们开发单页面应用程序更方便了 但是他最主要的就是为前端带来了MVVM开发模式 MVVM一句话：数据驱动视图，不操作DOM React Facebook公司自己开发的一个Web开发框架 组件化 Vue Vue作者：尤雨溪 早期由个人开发 Vue借鉴了angular和react之所长，后起之秀。 Vue.js介绍 Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。多页面：以服务端为主导，前后端混合 .php文件单页面：前后端分离，各司其职 服务端只处理数据 前端只处理页面（两者通过接口交互）模拟前后端分离开发模式 项目立项 需求分析 服务端的工作 需求分析 设计数据库 接口设计（有时候前端也需要参与其中） 接口开发（处理数据） 前端的工作 需求分析 写页面 页面写好功能 通过接口和服务端进行交互对比Angular React Vue.js更轻量，gzip后大小只有20k+ Vue.js更易上手，学习曲线平稳 吸取两家之长，借鉴了angular的指令和react的组件化Vue-cli Vue-cli是Vue的脚手架工具 脚手架是建筑工人搭建的架子，帮助工人作业 技术圈中的脚手架就是编写基础的代码，Vue-cli就是帮助我们写好Vue.js基础代码的工具 vue实例的生命周期 什么是生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期。生命周期钩子：就是生命周期事件的别名而已 主要的生命周期函数分类： 创建期间的生命周期函数： beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好data和methods属性 created：实例已经在内存中创建完毕，此时data和methods已经创建完毕，此时还没有开始编译模板 beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 mounted：此时，已经将编译好的模板挂载到了页面指定的容器中显示 运行期间的生命周期函数 beforeUpdate：状态更新之前执行次函数，此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有重新开始渲染DOM节点 updated：实例更新完毕之后调用次函数，此时data中的状态值和界面上显示的数据都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： beforeDestroy：实例销毁之前调用，在这一步，实例仍然完全可用。 destroyed：Vue实例销毁后调用，调用后，Vue实例指示的所有东西都会解绑，所有的事件监听器会被移除，所有的子实例也会被销毁 vue-resource实现get,post,jsonp请求jsonp的实现原理 除了vue-resource之外，还可以使用axios第三方包。 由于浏览器的安全性限制，不允许Ajax访问协议不同、域名不同、端口号不同的数据接口，浏览器认为这种访问不安全； 可以通过动态创建script标签的形式，把script标签的src属性，指向数据接口的地址，因为script标签不存在跨域限制，这种数据获取方式，称为JSONP（注意：根据jsonp的实现原理，所以只支持get请求）； 具体实现过程： 现在客户端定义一个回调方法，预定义对数据的操作； 再把这个回调方法的名称，通过URL传参的形式，提交到服务器的数据接口； 服务器数据接口组织好要发送的的客户端的数据，在拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； 客户端拿到服务器返回的字符串之后，当做Script脚本去解析执行，这样就能拿到JSONP的数据了； Vue中的动画 为什么要有动画：动画能够提高用户体验，帮助用户更好的理解页面中的功能； 官网 使用过渡类名 HTML结构 1234567&lt;div id="app"&gt; &lt;input type="button" value="动起来" @click="myAnimate"&gt; &lt;!-- 使用transition将需要过渡的元素包裹起来 --&gt; &lt;transition name="fade"&gt; &lt;div v-show="isshow"&gt;动画哦&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt; Vue实例 123456789101112// 创建Vue实例，得到viewModel let app = new Vue(&#123; el: '#app' data: &#123; isshow: false &#125;, methods: &#123; myAnimate()&#123; this.isshow = !this.isshow &#125; &#125; &#125;) 列表过渡 在实现列表过度的时候，如果需要过渡的元素是通过v-for渲染出来的，不能使用transition包裹，需要使用transition-group 如果要为v-for循环创建的元素设置动画，必须为每一个元素设置:key属性 给transition-group添加appear属性，实现页面刚展示出来的时候，入场的效果。 通过为transition-group元素设置tag属性，指定transition-group渲染为指定的元素，如果不指定tag属性，则默认渲染为span标签。 12345&lt;transition-group appear tag="ul"&gt; &lt;li v-for="(item,i) in list" :key="item.id" @click="del(i)"&gt; &#123;&#123;item.id&#125;&#125;=====&#123;&#123;item.name&#125;&#125; &lt;/li&gt;&lt;/transition-group&gt; 定义Vue组件 什么是组件： 组建的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可； 组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 全局组件定义的三种方式 使用Vue.extend配合Vue.component方法： 1234var login = Vue.extend(&#123; template: '&lt;h1&gt;登录&lt;/h1&gt;'&#125;);Vue.component('login',login); 直接使用Vue.component方法： 123Vue.component('register',&#123; template: '&lt;h1&gt;注册&lt;/h1&gt;'&#125;) 将模板字符串定义到scritp标签中： 123&lt;script id="tmp1" type="x-template"&gt; &lt;div&gt;&lt;a href="#"&gt;登录&lt;/a&gt; | &lt;a href="#"&gt;注册&lt;/a&gt;&lt;/div&gt;&lt;/script&gt; 同时，需要使用Vue.component来定义组件： 123Vue.component('account',&#123; template: '#tmp1'&#125;) 注意： 组建中的DOM结构，有且只能有唯一的根元素(root Element)来进行包裹！ 局部子组件注册方式12345678910111213141516171819&lt;div id="app"&gt; &lt;demo1&gt;&lt;/demo1&gt; &lt;/div&gt; &lt;template id="demo1"&gt; &lt;h1&gt;我是vm的私有组件&lt;/h1&gt; &lt;/template&gt; &lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, components: &#123; demo1: &#123; template: '#demo1' &#125; &#125; &#125;); &lt;/script&gt; 组件中展示数据和响应事件 在组件中，data被定义为一个方法，并且返回一个对象。如下： 1234567891011Vue.component('demo2',&#123; template: '#demo2', data()&#123; return &#123;msg: 0&#125; &#125;, methods: &#123; add()&#123; this.msg += 1 &#125; &#125;&#125;) 注意： 为什么组件中的data需要定义为一个方法并且返回一个对象？ 以计数器案例来演示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;vue-demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;h1&gt;错误案例&lt;/h1&gt; &lt;demo1&gt;&lt;/demo1&gt; &lt;demo1&gt;&lt;/demo1&gt; &lt;demo1&gt;&lt;/demo1&gt; &lt;h1&gt;正确案例&lt;/h1&gt; &lt;demo2&gt;&lt;/demo2&gt; &lt;demo2&gt;&lt;/demo2&gt; &lt;demo2&gt;&lt;/demo2&gt; &lt;/div&gt; &lt;template id="demo1"&gt; &lt;div&gt; &lt;button @click="add"&gt;+1&lt;/button&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;template id="demo2"&gt; &lt;div&gt; &lt;button @click="add"&gt;+1&lt;/button&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt; let message = &#123;msg: 0&#125;; // 定义一个全局组件demo1 Vue.component('demo1',&#123; template: '#demo1', data:function()&#123; return message; &#125;, methods: &#123; add()&#123; this.msg += 1; &#125; &#125; &#125;); Vue.component('demo2',&#123; template: '#demo2', data()&#123; return &#123;msg: 0&#125; &#125;, methods: &#123; add()&#123; this.msg += 1 &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在子组件中，如果将模板字符串定义到了script标签中，那么要访问子组件身上的data属性中的值，需要实用this来访问。 使用v-if和v-else切换组件 页面结构 123456789101112&lt;div id="app"&gt; &lt;a href="#" @click.prevent="onoff = true"&gt;登录&lt;/a&gt; &lt;a href="#" @click.prevent="onoff = false"&gt;注册&lt;/a&gt; &lt;login v-if="onoff"&gt;&lt;/login&gt; &lt;register v-else="onoff"&gt;&lt;/register&gt;&lt;/div&gt;&lt;template id="login"&gt; &lt;h1&gt;登录组件&lt;/h1&gt;&lt;/template&gt;&lt;template id="register"&gt; &lt;h1&gt;注册组件&lt;/h1&gt;&lt;/template&gt; 创建Vue实例 123456789101112131415var vm = new Vue(&#123; el: '#app', data: &#123; onoff: false &#125;, methods: &#123;&#125;, components: &#123; login: &#123; template: '#login' &#125;, register: &#123; template: '#register' &#125; &#125;&#125;); 多组件之间的切换，并添加切换动画页面结构： 使用commonent标签引用组件，并通过:is属性来指定要加载的组件； 1234567891011121314151617&lt;div id="app"&gt; &lt;a href="#" @click.prevent="trigger='login'"&gt;登录&lt;/a&gt; &lt;a href="#" @click.prevent="trigger='register'"&gt;注册&lt;/a&gt; &lt;a href="#" @click.prevent="trigger='logout'"&gt;退出&lt;/a&gt; &lt;transition mode="out-in"&gt; &lt;component :is="trigger"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt;&lt;template id="login"&gt; &lt;h1&gt;登录组件&lt;/h1&gt;&lt;/template&gt;&lt;template id="register"&gt; &lt;h1&gt;注册组件&lt;/h1&gt;&lt;/template&gt;&lt;template id="logout"&gt; &lt;h1&gt;退出组件&lt;/h1&gt;&lt;/template&gt; 创建Vue实例 123456789101112131415161718var vm = new Vue(&#123; el: '#app', data: &#123; trigger: 'login' &#125;, methods: &#123;&#125;, components: &#123; login: &#123; template: '#login' &#125;, register: &#123; template: '#register' &#125;, logout: &#123; template: '#logout' &#125; &#125;&#125;); 切换样式 123456789.v-enter,.v-leave-to &#123; opacity: 0; transform: translateX(60px);&#125;.v-enter-active,.v-leave-active &#123; transition: all .3s ease;&#125; #组件之间的通信 父组件向子组件传值 子组件默认无法访问父组件中的data上的数据和methods中的方法。 可以利用动态绑定属性的方式接受父组件中的数据，并且需要在子组件中用props数组定义一下才可以使用，并且props是只读的，不能修改。 12345678910111213141516171819&lt;div id="app"&gt; &lt;demo :par-msg="msg"&gt;&lt;/demo&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '我是父组件中的数据' &#125;, methods: &#123;&#125;, components: &#123; demo: &#123; template: '&lt;h1&gt;我是vm的子组件,这是父组件中的数据: &#123;&#123; parMsg &#125;&#125;&lt;/h1&gt;', props: ['parMsg'] &#125; &#125; &#125;);&lt;/script&gt; 子组件调用父组件的方法并向父组件传值 利用v-on接收父组件的方法，并且在子组件的methods中定义一个方法，在方法里面通过this.$emit(&#39;方法名&#39;)方法调用父组件中的方法。如果父组件的方法需要传参，则需要在this.$emit（&#39;方法名&#39;,参数1，参数2）添加第二个参数作为父组件方法的接收值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;div id="app"&gt; &lt;son @fun="doSomething"&gt;&lt;/son&gt;&lt;/div&gt;&lt;template id="son"&gt; &lt;div&gt; &lt;h1&gt;我是子组件son&lt;/h1&gt; &lt;!-- 接受父组件的方法 --&gt; &lt;input @click="sonFun" type="button" value="调用父组件的方法"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; let son = &#123; template: '#son', data() &#123; return &#123; sonMsg: &#123; name: 'jack', age: 12 &#125; &#125; &#125;, methods: &#123; sonFun() &#123; // 调用接收到的父组件的方法 this.$emit('fun', this.sonMsg) &#125; &#125; &#125; var vm = new Vue(&#123; el: '#app', data: &#123; sonData: null &#125;, methods: &#123; doSomething(data) &#123; this.sonData = data console.log('调用了父组件中的方法') &#125; &#125;, components: &#123; son, &#125; &#125;);&lt;/script&gt; 使用this.$refs来获取元素和组件1234567891011121314151617181920212223242526272829303132&lt;div id="app"&gt; &lt;div&gt; &lt;input type="button" value="获取元素内容" @click="getElement"&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref="myh1"&gt;这是一个h1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref="mycom"&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('my-com',&#123; template: '&lt;h4&gt;这是一个子组件&lt;/h4&gt;', data()&#123; return &#123; name: 'hello world' &#125; &#125; &#125;) let vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement()&#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name) &#125; &#125; &#125;)&lt;/script&gt; 在vue中使用vue-router 后端路由： 对于普通的网站，所有的超链接都是URL地址，所有的URL 地址都对应服务器上对应的资源； 前端路由： 对于一个单页面应用程序来说，主要通过URL中的hash（#号）来实现不同也main之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； vue-router的基本使用 创建一个路由对象，当导入vue-router包之后，在window全局对象中，就有了一个路由的构造函数：VueRouter 在new路由对象的时候，可以为构造函数传递一个配置对象 routes： 这个配置对象中的route表示【路由匹配规则】的意思，是一个数组。 每个路由规则都是一个对象，这个规则对象身上必须有两个属性 path： 表示监听哪个路由链接地址； component： 表示如果路由匹配到相应的path，则展示component属性对应的那个组件；（属性值必须是一个组件模板对象） 1234567891011121314151617181920212223242526272829&lt;div id="app"&gt; &lt;h1&gt;vue-router&lt;/h1&gt; &lt;!-- router-link 默认渲染为一个a标签 --&gt; &lt;router-link to="/login"&gt;Go to login&lt;/router-link&gt; &lt;router-link to="/register"&gt;Go to register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; let login = &#123; template: '&lt;h3&gt;登陆组件&lt;/h3&gt;' &#125; let register = &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125; let router = new VueRouter(&#123; routes: [ &#123;path: '/', redirect: '/login'&#125;,//重定向 &#123;path: '/login', component: login&#125;, &#123;path: '/register', component: register&#125; ], linkActiveClass: 'currentClass' &#125;) var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;);&lt;/script&gt; 补充： 使用tag属性指定router-link渲染的标签类型 linkActiveClass可以为当前选中组件添加类名。 在路由规则中定义参数12&lt;router-link to="/login?id=12"&gt;Go to login&lt;/router-link&gt;&lt;router-link to="/register:1111"&gt;Go to register&lt;/router-link&gt; 方式一：查询字符串 如果在路由中使用查询字符串给路由传递参数，则不需要修改路由规则的path属性。 1&#123;path: '/login', component: login&#125;, 使用this.$route.query.id获取参数 方式二： 占位符: 1&#123; path: '/register:name', component: register &#125; 使用this.$route.params.name获取参数 使用children属性实现路由嵌套 使用children属性实现子路由，注意：子路由的path前面不要带/，否则会以根路径进行请求。（这样不方便用户理解url地址） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id="app"&gt; &lt;router-link to="/account"&gt;点击展开&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id="tmp1"&gt; &lt;div&gt; &lt;h1&gt;这是account组件&lt;/h1&gt; &lt;router-link to="/account/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/account/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; let account = &#123; template: '#tmp1' &#125; let login = &#123; template: '&lt;h2&gt;登录组件&lt;/h2&gt;' &#125; let register = &#123; template: '&lt;h2&gt;注册组件&lt;/h2&gt;' &#125; let router = new VueRouter(&#123; routes: [ &#123; path: '/account', component: account, children: [ &#123;path: 'login', component: login&#125;, &#123;path: 'register', component: register&#125; ] &#125; ] &#125;) let vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;);&lt;/script&gt; 命名视图实习经典布局 给&lt;router-view&gt;添加name属性，可以在components配置对象中制定该标签要渲染的组件。 HTML结构 1234567&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="flexBox"&gt; &lt;router-view name="left"&gt;&lt;/router-view&gt; &lt;router-view name="main"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; JS 1234567891011121314151617181920212223242526let header = &#123; template: '&lt;h1 class="header"&gt;header&lt;/h1&gt;'&#125;let leftBox = &#123; template: '&lt;h1 class="left"&gt;leftBox&lt;/h1&gt;'&#125;let mainBox = &#123; template: '&lt;h1 class="main"&gt;mainBox&lt;/h1&gt;'&#125;let router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: header, left: leftBox, main: mainBox &#125; &#125; ]&#125;)var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router&#125;); 计算属性的特点 在computed中可以定义一些属性，叫做 计算属性，计算属性的本质就是一个方法，在使用计算属性的时候是把他们的名称直接当作属性来使用，并不会把计算属性当作方法去调用； 计算属性在引用的时候不要加()去调用，直接当作普通属性去使用； 只要计算属性内部所用到的任何data中的数据发生了变化，就会立即重新计算这个计算属性的值； 计算属性的求值结果会被缓存起来方便下次直接使用；如果计算属性方法中用到的任何数据都没有发生变化，则不会重新对计算属性求值。提高运行效率； watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算，主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的白哦大师，值是对应的回掉函数，主要用来监听某些特点数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； 在使用webpack构建的Vue项目中使用模板对象 import Vue from &#39;vue&#39;这种方式导入的是dist/vue.runtime.common.js这是由Vue包中的package.json中main属性决定的。 在webpack.config.js中添加resolve属性： 12345resolve:&#123; alias: &#123; 'vue$': 'vue/dist/vue.js' &#125;&#125; 直接导入包的路径 vue-loader vue-template-compiler的使用1npm i vue-loader vue-template-compiler -D webpack.config.js文件 12345module: &#123; rules: [ &#123;test: /\.vue$/, use: 'vue-loader'&#125; ]&#125; 注意： 还需要启用vue-loader中的插件才可以正常使用 12345const vueLoaderPlugin = require('vue-loader/lib/plugin')//在插件配置对象中plugins: [ new vueLoaderPlugin()] webpack中使用vue 安装vue的包： npm i vue 由于在webpack中推荐使用.vue这个组建模板定义组件，所以需要安装对应的loader： npm i vue-loader vue-template-compiler -D 在main.js中导入vue模块： import Vue from &#39;vue&#39; 定义一个.vue结尾的组件，组建有三部分组成： 123&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 使用import login form &#39;./login.vue&#39;导入这个组件（不要忘了配置loader） 创建vm实例 1234let vm = new Vue(&#123; el: '#app', render: c =&gt; c(login)&#125;) 在页面中创建一个id为app的div元素，作为vm实例要控制的区域； 在vue组件页面中，集成vue-router路由模块 vue-router官网 导入路由模块 1import VueRouter from 'vue-router' 将路由挂载到vue上 1Vue.use(VueRouter) 导入需要展示的组件 12import login from './components/login.vue'import register from './components/register.vue' 创建路由对象 1234567var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;); 将路由对象，挂载到 Vue 实例上 12345678var vm = new Vue(&#123; el: '#app', // render: c =&gt; &#123; return c(App) &#125; render(c) &#123; return c(App); &#125;, router // 将路由对象，挂载到 Vue 实例上&#125;); 组件中的css作用域 样式默认是全局的，如果想只在组件内部生效，可以为style标签添加scoped属性，实现原理是通过css的属性选择器实现的； 12&lt;style scoped&gt;&lt;/style&gt; 如果用less或者sass，则可以为style标签添加lang属性 12&lt;style scoped lang="less"&gt;&lt;/style&gt;]]></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS模块化]]></title>
    <url>%2F2019%2F01%2F17%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起，这就是JS模块化。块的内部数据/实现是私有的，只是向外暴露一些接口（方法）与外部其他模块通信。 模块化规范CommonJS规范说明 每个文件都可当做一个模块 在服务器端：模块的加载是运行时同步加载的 在浏览器端：模块需要提前编译打包处理基本语法暴露模块 module.exports = value exports.xxx = value引入模块require(xxx) 第三方模块、系统模块xxx为模块名 自定义模块xxx为模块文件路径 实现服务端实现Node.js 浏览器端实现Browserify也称为CommonJS的浏览器端的打包工具 Browserify模块化使用教程 创建目录结构 123456789|- js |- dist // 打包生成文件的目录 |- src // 源码所在的目录 |- module1.js |- module2.js |- module3.js |- app.js // 应用主源文件|- index.html|- package.json 下载browserify 全局安装 1npm install browserify -g 局部安装 1npm install browserify --save-dev 打包处理js 12browserify js/src/app.js -o js/dist/bundle.js # -o output输出 前面是要打包的文件，后面是输出后的位置及文件名 AMD规范说明 Asynchronous Module Definition（异步模块定义） https://github.com/amdjs/amdjs-api/wiki/AMD 专门用于浏览器端，模块的加载是异步的基本语法定义暴露模块 123456789//定义没有依赖的模块define(function()&#123; return 模块&#125;)//定义有依赖的模块define(['module1','module2'],function(m1,m2)&#123; return 模块&#125;) 引入使用模块123require(['moudle1','moudle2'],function(m2,m2)&#123; 使用m1/m2&#125;) 实现（浏览器端） Require.js http://www.requirejs.cn/ http://www.ruanyifeng.com/blog/2012/11/require_js.htmlrequire.js使用教程 下载require.js ，并引入 js/libs/require.js 创建项目结构 12345678|-js |- libs |- require.js |- modules |- modules1.js |- modulew2.js |- main.js|- index.html 定义require.js的模块代码 应用主(入口)js: main.js 12345678910111213141516171819202122232425262728293031(function () &#123; //配置 require.config(&#123; //基本路径 baseUrl: 'js/', //映射: 模块标识名: 路径 paths: &#123; //自定义模块 'alerter': 'modules/alerter', 'dataService': 'modules/dataService', //库模块 'jquery': 'libs/jquery-1.10.1', 'angular': 'libs/angular' &#125;, //配置不兼容AMD的模块 shim: &#123; angular: &#123; exports: 'angular' &#125; &#125; &#125;) //引入模块使用 require(['alerter', 'angular'], function (alerter, angular) &#123; alerter.showMsg() console.log(angular); &#125;)&#125;)() 引入require.js并指定js主文件的入口 1&lt;script type="text/javascript" src="js/libs/require.js" data-main="js/main.js"&gt;&lt;/script&gt; CMD（了解）规范说明 Common Module Definition（通用模块定义） https://github.com/seajs/seajs/issues/242 专门用于浏览器端，模块的加载是异步的 模块使用时才会加载执行基本语法定义暴露模块 12345678910111213141516//定义没有依赖的模块define(function(require,exports,module)&#123; exports.xxx = value module.exports = value&#125;)//定义有依赖的模块define(function(require,exports,module)&#123; //引入依赖模块（同步） var module2 = require('./module2') //引入依赖模块（异步） require.async('./module3',function(m3)&#123; &#125;) //暴露模块 exports.xxx = value&#125;) 引入使用模块123456define(function(require)&#123; var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()&#125;) 实现（浏览器端） Sea.js http://www.zhangxinxu.com/sp/seajs 12345678910111213141516&lt;!--使用seajs: 1. 引入sea.js库 2. 如何定义导出模块 : define() exports module.exports 3. 如何依赖模块: require() 4. 如何使用模块: seajs.use()--&gt;&lt;script type="text/javascript" src="js/libs/sea.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; seajs.use('./js/modules/main')&lt;/script&gt; ES6*规范说明 http://es6.ruanyifeng.com/#docs/module 依赖模块需要编译打包处理 语法 导出模块：export，export default 引入模块：import xxx，{xxx} from &#39;路径&#39;export和export default的区别 ​ export default export default向外暴露的成员，可以使用任意的变量来接受， 在一个模块中，export default只允许向外暴露一次， 在一个模块中可以同时使用export default和export向外暴露成员， export 使用export向外暴露的成员，只能使用{}的形式来接收，这种形式叫（按需导出）， export可以向外暴露多个成员，同时，如果某些成员在import的时侯不需要则可以不在{}中定义 使用export导出的成员必须严格安装导出时的名称使用{}接收， 如果想换个名称来接收的话可以使用as改名； 例如： module1.js 1export msg = 'hello world' module2.js 1import &#123;msg as msg222&#125; from './m' 实现（浏览器端） 使用Babel将ES6编译为ES5代码 使用Browserify编译打包jsES6-Babel-Browserify使用教程 安装babel-cli,babel-preset-es2015和browserify 12npm install babel-cli browserify -gnpm install babel-preset-es2015 --save-dev 定义.babelrc文件 123&#123; "presets": ["es2015"]&#125; 定义.babelrc文件 123&#123; "presets":["es2015"]&#125; 编码 js/src/module1.js 分别暴露 1234567export function foo() &#123; console.log('module1 foo()');&#125;export function bar() &#123; console.log('module1 bar()');&#125;export const DATA_ARR = [1, 3, 5, 1] js/src/module2.js 统一暴露 1234567891011let data = 'module2 data'function fun1() &#123; console.log('module2 fun1() ' + data);&#125;function fun2() &#123; console.log('module2 fun2() ' + data);&#125;export &#123;fun1, fun2&#125; js/src/module3.js默认暴露 123456export default &#123; name: 'Tom', setName: function (name) &#123; this.name = name &#125;&#125; js/src/app.js 12345678910111213141516import &#123;foo, bar&#125; from './module1'import &#123;DATA_ARR&#125; from './module1'import &#123;fun1, fun2&#125; from './module2'import person from './module3'import $ from 'jquery'$('body').css('background', 'red')foo()bar()console.log(DATA_ARR);fun1()fun2()person.setName('JACK') 编译 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib 使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js 页面中引入测试 1&lt;script type="text/javascript" src="js/lib/bundle.js"&gt;&lt;/script&gt; 引入第三方模块(jQuery) 下载jquery模块 在app.js中引入并使用12import $ from 'jquery'$('body').css('background', 'red')]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[配置browser-sync浏览器同步测试工具]]></title>
    <url>%2F2018%2F07%2F17%2F%E9%85%8D%E7%BD%AEbrowser%E2%80%94-sync%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%AD%A5%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[BrowserSync是基于Node.js的, 是一个Node模块， 如果想要使用它，需要先安装一下Node.js 官方网站：https://browsersync.io/中文参考网站：http://browsersync.cn/ 安装全局安装12#简写方式：npm i -D browser-syncnpm install -g browser-sync 在项目中安装1npm install --save-dev browser-sync 在项目中配置scripts在项目的包描述文件中插入以下代码 1234"scripts":&#123; "dev": "browser-sync start --server --files \"*.html, css/*.css, js/\"", "start": "npm run dev" &#125; 启动项目在命令行中输入以下，即可启动项目 1npm start]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记]]></title>
    <url>%2F2018%2F06%2F17%2FES6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 入门 阮一峰 著 常用 let和const关键字let作用与var类似，用于声明一个变量 特点 在块级作用域有效 不能重复声明 不会预处理，不存在变量提升应用： 循环遍历加监听 使用let取代var是趋势const作用 定义一个常量特点 不能修改（引用值可以改变） 其他特点同let应用 保存不用更改的数据变量的解构赋值理解：从对象或数组中提取数据，并赋值给变量（多个）对象的解构赋值 1let &#123;n,a&#125; = &#123;n:'tom',a:12&#125; 数组的解构赋值1let [a,b] = [1,'abc'] 用途给多个形参赋值 EX：123456789101112131415161718//ES5var obj = &#123;userName:'tom',lastName:'li'&#125;var userName = obj.userName;var lastName = obj.lastName;//ES6let obj = &#123;userName:'tom',lastName:'li'&#125;let &#123;userName,lastName&#125; = objconsole.log(userName,lastName)let arr = [1,3,5,'abc',true];let [,,a,b] = arr;console.log(a,b)//为形参赋值function foo (&#123;userName,lastName&#125;)&#123; console.log(userName,lastName)&#125;foo(obj) 模板字符串作用：简化字符串的拼接 语法模板字符串必须写在两个`（反引号）里面，变化部分使用${xxx}`定义 123let name = 'tom'let age = 13console.log(`my name is $&#123;name&#125;,my age is $&#123;age&#125;`) 简化的对象写法 省略同名的属性值 省略方法的function 123456let x = 1;let y = 2;let point = &#123; x, y, set(x) &#123;this.x = x&#125; 箭头函数 箭头函数特点： 简洁 箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是定义的时候处在的对象就是他的this 扩展理解： 箭头函数的this看外层是否有函数， 如果有，外层函数的this就是内部箭头函数的this， 如果没有，this就指向window形参的情况123456789//1. 没有形参的时候 必须有（）let fun = () =&gt; console.log('我是箭头函数');fun();//2. 只有一个形参的时候（） 可以省略let fun1 = a =&gt; console.log(a)fun1('hehe');//3. 两个及两个以上 （） 不能省略let fun2 = (a,b,c,...) =&gt; console.log(x,y);fun2() 函数体的情况12345678910//1. 函数体只有一条语句或者是表达式 &#123;&#125; 可以省略----&gt;会自动返回语句执行结果或者是表达式的结果。let fun3 = (x,y) =&gt; x + y;console.log(fun3(1,3))// 2. 函数体不止一条语句或者是表达式的情况 &#123;&#125; 不可以省略let fun4 = (x,y) =&gt; &#123; console.log(x,y); //需要手动返回 return x + y;&#125;;console.log(fun4(35,49)); 点点点运算符用途 rest（可变）参数 用来取代arguments 但比arguments灵活，只能是最后部分形参参数（如果...value前面还有形参，那么...value就是剩下的形参，而且...value只能放到最后面 ） 123456789101112function fun(...value) &#123; console.log(arguments); //arguments是伪数组，没有forEach方法，所以下面会报错 /*arguments.forEach(function(item, index) &#123; console.log(item, index); &#125;)*/ console.log(value); value.forEach(function(item, index) &#123; console.log(item, index); &#125;)&#125;fun(1,2,3,3) 扩展运算符 1234let arr1 = [2,3,4,5];let arr2 = [1,...arr1,6];console.log(arr2);// ====&gt; [1,2,3,4,5,6] 形参默认值当不传入参数的时候默认使用形参里的默认值 12345678function Point(x=1,y=2)&#123; this.x = x; this.y = y;&#125;let point = new Point()console.log(point)let point2 = new Point(3,4)console.log(point2) 输出结果： Promise对象理解： Promise对象：代表了未来某个将要发生的事件（通常是一个异步操作） 有了promise对象，可以将异步操作以同步的流程表达出来，避免回调地狱 ES6的Promise是一个构造函数，用来生成promise实例使用promise基本步骤（2步）1234567891011121314// 创建promise对象let promise = new Promise((resolve,reject) =&gt; &#123; //初始化promise状态为pending //执行异步操作 if(异步操作成功)&#123; resolve(value);//修改promise的状态为fullfilled &#125; else &#123; reject(errMsg);//修改promise状态W为rejected &#125;&#125;)// 调用promise的then()promise.then(function(result =&gt; console.log(result),errorMsg =&gt; alert(errorMsg))) promise对象的三个状态 pending： 初始化状态 fullfilled： 成功状态 rejected： 失败状态应用： 使用promise实现超时处理 使用promise封装处理Ajax请求 12345let request = new XMLHttpRequest();request.onreadystatechange = function()&#123;&#125;request.responseType = 'json';request.open("GET",url);request.send(); Symbol ES5中对象的属性名都是字符串，容易造成重名，污染环境 概念：ES6中的 添加了一种原始数据类型symbol 特点： Symbol属性对应的值是唯一的 Symbol值不能与其他数据进行计算，包括同字符串拼串 for in，for of遍历时不会遍历symbol属性使用： 调用Symbol函数得到symbol值 123let symbol = Symbol();let obj = &#123;&#125;;obj[symbol] = 'hello'; 传参标识 1234let symbol = Symbol('one');let symbol2 - Symbol('two');console.log(symbol);//Symbol('one')console.log(symbol2);//Symbol('two') 内置Symbol值 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部的使用方法。 Symbol.iterator 对象的Symbol.iterator属性，指向该对象的默认遍历器方法Iterator遍历器概念：Iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制作用： 为各种数据结构，提供统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6创造了一种新的遍历命令for...of循环，Iterator接口机制主要供for...of消费工作原理 创建一个指针对象（遍历器对象），指向数据结构的起始位置。 第一次调用next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针会一直往后移动，知道指向最后一个成员 每调用next方法返回的是一个包含value和done的对象，value：当前成员的值，done：布尔值 value表示当前成员的值，done对应的布尔值表示当前的数据结构是否遍历结束。 当遍历结束的的时候返回的value 的值是undefined,done值为false 原生具备iterator接口的数据（可用for of遍历） 扩展理解 当数据结构上部署了Symbol.iterator接口，该数据就是可以用for of遍历Generator函数概念： ES6提供的解决异步编程的方案之一 Generator函数是一个状态机，内部封装了不同状态的数据 用来生成遍历器对象 可暂停函数（惰性求值），yield可暂停，next方法可启动。每次返回的是yield后的表达式结果。特点： function与函数名之间有一个*号 内部用yield表达式来定义不同的状态 例如： 1234function* generatorExample()&#123; let result = yield 'hello'; // 状态值为hello yield 'generator'; // 状态值为generator&#125; generator函数返回的是指针对象,而不会执行函数内部逻辑。 调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yiedl后的表达式结果/undefined，done: true/false} 再次调用next方法会从上一次停止时的yield处开始，直到最后 yield语句返回结果通常为undefined，当调用next方法时传参内容会作为启动时yield语句的返回值。async函数（源自ES2017）概念：真正意义上去解决异步回调的问题，同步流程表达异步操作本质Generator的语法糖语法： 1234async function foo()&#123; await 异步操作; await 异步操作;&#125; 特点： 不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就会往下执行。 返回的总是Promise对象，可以用then方法进行下一步操作 async取代Generator函数的*号，await取代Generator的yield 语义上更为明确，使用简单。class 通过class定义类/实现类的继承 在类中通过constructor定义构造方法 通过new 来创建类的实例 通过extends类的继承 通过super调用父类的构造方法 里面必须用对象的简写方法 123456789101112131415161718192021222324252627282930//定义一个人物的类//父类class Person &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; //类的一般方法 sayHi()&#123; console.log('hi'); &#125;&#125;let person = new Person('jack',23);console.log(person);person.sayHi(); // hi//子类class StarPerson extends Person&#123; constructor(name,age,salary)&#123; super(name,age);//调用父类的构造方法 this.salary = salary; &#125; //父类的方法重写，没有的话实例会向上找到父类的方法 sayHi()&#123; console.log('hello') &#125;&#125;let p1 = new StarPerson('tom',34,120000)console.log(p1);p1.showName();// hello 其他 字符串扩展 includes(str) 判断是否包含指定的字符串 123let str = 'sagkajsgjgsjg';console.log(str.includes('t'))//falseconsole.log(str.includes('s'))//true startsWith(str) 判断是否以指定字符串开头 1console.log(str.startsWith('sa'))//true endsWith(str) 判断是否以指定字符串结尾 1console.log(str.endsWith('g'))//true repeat(count) 重复指定次数 12let str = 'abc';console.log(str.repeat(3))//abcabcabc padStart(maxLength,fillstring=&#39;&#39;)从首位填充字符串 1234//例如处理时间的情况，日期为单数则前面加一个0let date = new Date()let Month = date.getMonth()Month.toString().padStart(2,'0') // 0X padEndt(maxLength,fillstring=&#39;&#39;)从末位填充字符串数值的扩展 二进制与八进制数值表示法：二进制用0b，八进制用0o 12console.log(0b1010);//10console.log(0o56);//46 Number.isFinite(i) 判断是否是有限大的数，Infinity无穷大 Number.isNaN(i) 判断是否是NaN Number.isInteger(i) 判断是否是整数 Number.parseInt(str) 将字符串转换为对应的数值 Math.trunc(i) 直接去除小数部分数组的扩展 Array.from(v) 将伪数组对象或可遍历对象转换为真数组 1234let btns = document.getElementsByTagName('button');//伪数组Array.form(btns).forEach(function(item,index)&#123; console.log(item);&#125;) Array.of(v1,v2,v3) 将一系列数值转换为数组 12let arr = Array.of(1,34,6,'ba',true);console.log(arr); //[1,34,6,'ba',true] find(function(value,index,arr){return true})找出第一个满足条件返回true的元素 123456let arr = [1,2,3,4,5];let result = arr.find(function(item,index)&#123; return item &gt; 2&#125;)console.log(result)//3 findIndex(function(value,index,arr){return true}) 找出第一个满足条件返回true的元素的下标 123456let arr = [1,2,3,4,5];let result = arr.findIndex(function(item,index)&#123; return item &gt; 2&#125;)console.log(result)//2 Object扩展 Object.is(v1,v2) 判断2个数据是否完全相等（以字符串形式判断） Object.assign(target,source1,source2..) 将源对象的属性复制到目标对象上 12345let obj = &#123;&#125;;let obj1 = &#123;username: 'jack',age: 23&#125;let obj2 = &#123;sex: 1&#125;console.log(Object.assign(obj,obj1,obj2))// &#123;username: 'jack',age: 23,sex: 1&#125; 直接操作__proto__属性 12let obj2 = &#123;&#125;;obj2.__proto__ = obj1; 深度克隆拷贝数据 基本数据类型： 拷贝后会生成一份新的数据，修改拷贝后的数据不会影响原数据 对象/数组 拷贝后不会生成新的数据，而是引用。修改拷贝后的数据会影响原来的数据 直接赋值给一个变量 浅拷贝 Object.assign() 浅拷贝 Array.prototype.concat() 浅拷贝 Array.prototype.slice() 浅拷贝 JSON.parse(JSON.stringify()) 深拷贝（深度克隆），拷贝的数据里不能有函数，处理不了。Set容器和Map容器Set容器：无序不可重复的多个value的集合体 Set() Set(array) add(value) delete(value) has(value) clear() size 1let set = new Set([1,2,3,4,5]) Map容器：无序的key不重复的多个key-value的集合体 Map() Map(array) set(key,value) //添加 get(key) delete(key) has(key) clear() size 12//以二位数组的形式传入多个key-valuelet map = new Map([['key','value'],[23,'age']]) ES7 ES7正式发布的 指数运算符（幂）：** 1console.log(3 ** 3) // 27 Array.prototype.includes(value) 判断数组中是否包含指定value]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular入门和使用]]></title>
    <url>%2F2018%2F06%2F13%2FAngular%E5%85%A5%E9%97%A8%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端框架</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用JS代码段]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%B8%B8%E7%94%A8JS%E4%BB%A3%E7%A0%81%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[HTML5 DOM选择器1234567//querySelector() 返回匹配到的第一个元素var item = document.querySelector('.item');console.log(item);//querySelectorAll() 返回匹配到的所有元素，是一个nodeList集合var items = document.querySelectorAll('.itme');cosole.log(item[0]); 阻止默认行为12345678910111213141516//原生jsdocument.getElementById('btn').addEventListener('click',function(event)&#123; event = event || window.event; if (event.preventDefault)&#123; //主流浏览器阻止默认行为 event.preventDefault(); &#125; else&#123; //IE阻止默认行为 event.returnValue = false; &#125;&#125;,false);//JQuery$('#btn').on('click',function(event)&#123; event.preventDefault();&#125;); 阻止冒泡12345678910111213141516//原生jsdocument.getElementById('btn').addEventListener('click',function(e)&#123; event = event || window.event; if (event.stopPropagation)&#123; // 主流浏览器阻止冒泡 event.stopPropagation(); &#125; else &#123; //ie阻止冒泡 event.cancelBubble = true; &#125;&#125;,false);//jQuery$('#btn').on('click',function(e)&#123; event.stopPropagation();&#125;); 鼠标滚轮事件1234567891011$('#content').on('mousewheel DOMMouseScroll',function(e)&#123; //滚动兼容处理 var delta = (event.originalEvent.wheelDelta &amp;&amp; (event.originalEvent.wheelDelta &gt; 0 ? 1 : -1)) || (event.originalEvent.detail &amp;&amp; (event.originalEvent.detail &gt; 0 ? -1 : 1)); if (delta &gt; 0) &#123; //向上滚动 console.log('mousewheel top'); &#125; else if (delta &lt; 0)&#123; //向下滚动 console.log('mousewheel bottom'); &#125;&#125;) 检查浏览器是否支持svg1234function isSupportSVG() &#123; var SVG_NS = 'http://www.w3.org/2000/svg'; return !!document.createElementNS &amp;&amp;!!docunent.createElementNS(SVG_NS,'svg').createSVGRect;&#125; 检查浏览器是否支持canvas123456789function isSupportCanvas()&#123; if(document.createElemetn('canvas').getContext)&#123; return true; &#125; else &#123; return false; &#125; //测试，打开浏览器查看结果 console.log(isSupportCanvas());&#125; 检查是否是微信浏览器12345678910function isWeiXinClient() &#123; var ua = navigator.userAgent.tolowerCAse(); if (ua.match(/MicroMessenger/i) == "micromessenger") &#123; return true; &#125; else &#123; return false; &#125;&#125;//测试console.log(isWeiXinClient()); 常用的一些正则表达式1234567891011121314//匹配字母、数字、中文字符/^([A-Za-z0-9]|[\u4e00-\u9fa5])*$/;//验证邮箱/^\w+@([0-9a-zA-Z]+[.])+[a-z]&#123;2,4&#125;$/;//验证手机号/^1[3|5|8|7]\d&#123;9&#125;$/;//验证URL/^http:\/\/.+\./;//验证身份证号码/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;([0-9]|x|X)$)/;//匹配中文字符的正则表达式/[\u4e00-\u9fa5]/;//匹配双字节字符（包括汉字在内）/[^\x00-\xff/; js时间戳、毫秒格式化123456789101112function formatDate(now) &#123; var y = now.getFullYear(); var m = now. getMonth() + 1; var d = now.getDate(); var h = now.getHours(); var m = now.getMinutes(); var s = now.getSeconds(); return y + '-' + m + '-' + d + ' ' + h + ':' + m + ':' + s;&#125;var nowDate = new Date(2018,5,13,19,18,30,20);console.log(nowDate.getTime());//获得当前毫秒数console.log(formatDate(nowDate)); getBoundingClientRect()获取元素位置12345678//它返回一个对象，其中包含了left、right、top、bottom四个属性var myDiv = document.getElementById('myDiv');var x = myDiv.getBoundingClientRect().left;var x = myDiv.getBoundingClientRect().top;/* 相当于jquery的: $(this).offset().left、$(this).offset().top 相当于js的： this.offsetLeft、this.offsetTop*/ HTML5全屏123456789101112function fullscreen(element)&#123; if (element.requestFullScreen) &#123; element.requestFullscreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen(); &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125;&#125;fullscreen(document.documentElement);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>常用</tag>
        <tag>代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js入门和使用]]></title>
    <url>%2F2018%2F05%2F17%2Fnode.js%E5%85%A5%E9%97%A8%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nodejs是什么 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js不是一门语言 Node.js不是库、不是框架 是一个JavaScript运行时环境 简单来讲就是Node.js可以解析和执行JavaScript代码 以前只有浏览器可以解析JavaScript代码 现在JavaScript可以完全脱离浏览器来执行，一切都归功于：Node.js 浏览器中的JavaScript ECMAScript 基本语法 if var function Object Array BOM DOM Node.js中的JavaScript 没有BOM、DOM ECMAScript 在node这个js执行环境中为JavaScript提供了一些服务器级别的操作API 例如文件读写 网络服务的构建 网络通信 http服务器 等处理、、、、 构建与chrome浏览器v8引擎之上 代码只是具有特定格式的字符串 引擎可以认识他，可以帮你去解析和执行 Google Chrome的v8引擎是目前公认的解析执行JavaScript代码最快的 Node.js的作者把Google Chrome中的V8引擎移植了出来，开发了一个独立的JavaScript运行时环境。 Node.js uses an event-driven,non-blocking I/O model that makes it lightweight and efficient. event-driven 事件驱动 non-blocking I/O model 非阻塞IO模型（异步） lightweight and efficient. 轻量和高效 Node.js package ecosytem,npm,is the largest ecosystem of open source libraries in the world npm是世界上最大的开源库生态系统 绝大多数JavaScript相关的包都存放在npm上，这样做的目的是为了让开发人员更方便的去下载使用。 npm install jquery Node.js可以做什么 web服务器后台 命令行工具 npm（node） git（c语言） hexo（node） 。。。 对于前端开发工程师来讲，接触node最多的是他的命令行工具 自己写的很少，主要是使用第三方开发的 webpack gulp npm预备知识 HTML css JavaScript 简单的命令行操作 具有服务端开发经验更佳一些资源 《深入浅出Node.js》 朴灵 偏理论，几乎没有任何实战性内容 理解原理底层有帮助 《Node.js权威指南》 API讲解 没有业务，没有实战 JavaScript标准参考教程（alpha）： https://wangdoc.com/javascript/ Node入门： http://www.nodebeginner.org/index-zh-cn.html 官方API文档： https://nodejs.org/dist/latest-v6.x/docs/api/ CNODE社区：http://cnodejs.org CNODE-新手入门： http://cnodejs.org/getstart可以学到什么 B/S编程模型 Browser-Server back-end 任何服务端技术这种BS编程模型都是一样，和语言无关 Node只是我们学习BS编程模型的的一个工具而已 模块化编程 RequireJS SeaJS @import(&#39;文件路径&#39;) 以前认知的的JavaScript只能通过script标签来加载 在Node中可以像@import ()一样来引用加载JavaScript脚本文件 Node常用API 异步编程 回调函数 Promise async generator Express Web开发框架 学习node不仅会帮助大家打开服务端黑盒子，同时会帮助你学习前端高级内容 Vue.js React angular 起步安装Node环境 查看当前Node环境的版本号node --version 环境变量REPL read 读取 eval 执行 print 输出 loop 循环在终端输入node命令直接敲回车这个环境的作用只是用来帮助我们做一些辅助测试，例如在里面可以直接使用node中的核心模块而不需要require加载。HelloWorld 创建编写JavaScript脚本文件 打开终端，定位到脚本文件所属目录 输入node文件名执行对应文件注意： 文件名不要使用node.js来命名！ 解析执行JavaScript 读写文件 浏览器中的JavaScript是没有文件操作的能力的 但是Node中的JavaScript具有文件操作的能力 fs是file-system的简写，就是文件系统的意思 在Node中如果想要进行文件操作，就必须引入fs这个核心模块 在fs这个核心模块中，就提供了所有的文件操作相关的API 例如：fs.readFile就是用来读取文件的 使用require方法加载fs核心模块1234567891011121314151617181920212223// 1.使用require方法加载fs核心模块var fs = require('fs');/* 2.读取文件第一个参数是要读取的文件路径第二个参数就是一个回调函数 成功 data 数据 error null 失败 data null error 错误对象*/fs.readFile('data/readfile.txt',function(error,data)&#123; // console.log(data); console.log(data.toString());/* &lt;Buffer 68 65 6c 6c 6f 20 6e 6f 64 65 6a 73 0d 0a e4 bd a0 e5 a5 bd 20 6e 6f 6465 6a 73&gt;文件中存取的其实都是二进制数据这里为什么看到的不是0和1呢？原因是二进制转为了16进制但是无论是二进制还是16进制，人类都不认识所以可以通过toString方法转为我们能认识的字符*/&#125;); 创建http服务 我们可以使用Node非常轻松的构建一个web服务器 在Node中专门提供了一个核心模块：http http这个模块的职责就是帮你创建编写服务器的1234567891011121314151617181920//1.加载http核心模块var http = require('http');//2.使用http.createServer()方法创建一个web服务器// 返回一个Server实例var server = http.createServer();//3.服务器要干嘛// 提供服务：对数据的服务// 发送请求// 接受请求// 处理请求// 发送响应//3.绑定端口号，启动服务器server.listen(3000,function()&#123; console.log('服务器启动成功，通过http://127.0.0.1:3000/ 进行访问');&#125;);// 4.注册request请求事件// 当客户端请求过来，就会自动触发request请求事件，然后执行第二个参数（回调函数） server.on('request',function()&#123; console.log('接收到客户端请求');&#125;); request请求处理函数 12345678910111213141516171819202122var http = require('http');var server = http.createServer();server.listen(3000,function()&#123; console.log('服务器启动成功，通过http://127.0.0.1:3000/ 进行访问');&#125;);/*request请求事件处理函数，需要接受两个参数 Request请求对象 请求对象可以用来获取客户端的一些请求信息，例如请求路径 Response响应对象 响应对象可以用来给客户端发送响应消息*/server.on('request',function(request,response)&#123; console.log('接收到客户端请求,请求路径是：'+ request.url); /*response对象有一个方法：write可以用来给客户端发送响应数据 write可以使用多次，但是最后一定要使用 “end” 来结束响应，否则客户端会一直等待*/ /*response.write('hello '); response.write('this is node.js'); response.end();*/ //上面write的方式比较麻烦，可以直接end的同时发送数据 response.end('hello this is node.js');&#125;); 响应内容只能是二进制数据或者字符串Node中的模块系统 ECMAScript 核心模块 第三方模块 用户自定义模块核心模块Node为JavaScript提供了很多服务器级别的API，这些API绝大多数都被包装到了一个具名的核心模块中。例如： 文件操作的fs核心模块fs核心模块中readFileAPI的第二个参数是可选的，传入utf8可以把读取到的文件直接按照utf8编码转成我们能认识的字符（默认是二进制）,除了这种方法，也可以通过data.toString()方法。 123456fs.readFile('./db.json','utf8',function(err,data)&#123; if(err)&#123; return res.status(500).send('Server error...') &#125; console.log(data)&#125;) http服务构建的http模块 url路径操作模块 path路径操作模块 os操作系统信息模块 。。。 详细见node官方API文档只要是这个模块是一个核心模块，就必须使用require方法来引入。1234567891011//用来获取机器信息的var os = require('os');//用来操作路径的var path = require('path');//获取当前机器的CPU信息console.log(os.cpus());//memory 内存console.log(os.totalmem());//获取一个路径中的扩展名部分//extname extension nameconsole.log(path.extname('D:/a/c/d/c/hellow.txt')); path路径操作模块参考文档：https://nodejs.org/dist/latest-v11.x/docs/api/path.html path.basename 获取一个路径的文件名（默认包含扩展名） path.dirname 获取一个路径中的目录部分 path.extname 获取一个路径中的扩展名部分 path.parse 把一个路径转为对象 root 根路径 dir 目录 base 包含后缀名的文件名 ext 后缀名 name 不包含后缀名的文件名 path.join 当需要进行路径拼接的时候，推荐使用这个方法 path.isAbsolute 判断一个路径是否是绝对路径Node中的其他成员在每个模块中，除了require、exports等模块相关API之外，还有两个特殊成员： __dirname 动态获取 可以用来获取当前文件模块所属目录的绝对路径 __filename 动态获取 可以用来获取当前文件的绝对路径 __dirname和__filename是不受执行node命令所属路径影响的在文件操作中，使用相对路径是不可靠的，因为在Node中文件操作的路径被设计为相对执行node命令所处的终端路径（这不是bug）。所以为了解决这个问题，只需要把相对路径变为绝对路径。我们可以使用__dirname或者__filename来解决这个问题。在拼接路径的过程中，为了避免手动拼接带来的一些低级错误，所以推荐多使用：path.join()来辅助拼接。所以为了尽量避免这个问题，以后再文件操作中使用的相对路径都统一换为动态的绝对路径 补充：模块中的路径标识和这里的路径没关系，不受影响（就是相对于文件模块） 用户自定义模块 require require是用来加载模块的 在Node中，模块有三种： 具名的核心模块，例如：fs,http 用户自己编写的文件模块 相对路径必须加./（不然会当做核心模块）。 可以省略后缀名 在Node中，没有==全局作用域==，只有==模块作用域== 外部访问不到内部 内部也访问不到外部 默认都是封闭的 既然是模块作用域，那如何让模块和模块之间进行通信 有时候我们加载文件模块的目的不是为了简简单单的执行里面的代码，更重要的是使用里面的成员。 require方法的第二个作用：拿到被加载文件模块导出的接口对象 在每个文件模块中都提供了一个对象：exports exports exports默认是一个空对象 我们要做的就是把所有需要被外部访问的成员挂载到这个exports对象中。 如果一个模块需要直接导出某个成员，而非挂载的方式。那我们就需要用到下面这个方法module.exports = &#39;hello&#39;加载和导出的使用规则require加载规则如果想要了解更多底层细节，可以自行参考：《深入浅出Node.js》中的模块系统章节。 语法：var 自定义变量名 = require(&#39;模块&#39;) 核心模块 模块名 第三方模块 模块名 自己写的模块 路径 两个作用： 执行被加载模块中的代码 得到被加载模块中的exports导出的接口对象 优先从缓存加载 这里b.js只被执行了一次优先从缓存加载，由于a中已经加载过b了，所以这里不会重复加载，可以拿到其中的接口对象，但是不会重复执行里面的代码。这样做的目的是为了 避免重复加载， 提高模块加载效率。 判断模块标识 核心模块本质也是文件，已经被编译到二进制文件中了，我们只需要按照名字来加载就可以了。require(&#39;fs&#39;)require(&#39;http&#39;) 第三方模块凡是第三方模块都必须通过npm来下载使用的时候就可以通过require(&#39;包名&#39;)的方式来进行加载就可以使用不可能有任何一个第三方包和核心模块的名字是一样的既不是核心模块，也不是路径形式的模块 模块加载机制：`node_modules/art-template` `node_modules/art-template/package.json文件` `node_modules/art-template/package.json文件中的main属性` `main属性中就记录了art-template的入口模块` `然后加载使用这个第三方包` `实际上最终加载的还是文件` 如果package.json文件不存在或者main指定的入口模块也没有 则node会自动找该目录下的index.js。(index.js会作为默认备选项) 如果以上所有条件都不成立，则会进入上一级目录中的node_modules目录查找，如果上一级也没有，则逐级向上查找，直到磁盘根目录，最后报错`Can not find module xxx`。 一个项目中有且仅有一个node_modules而且是存放在项目的根目录。 自己写的模块 路径形式的模块：./当前目录，不可省略../上一级目录，不可省略/几乎不用，macOS和linux的磁盘根目录d:/a/foo.js/几乎不用 导出exports Node中是模块作用域，默认文件中的所有成员只在当前文件模块中有效 对于希望可以被其他模块访问的成员，我们就需要把这些公开的成员都挂载到exports接口对象中就可以了 导出多个成员（必须在对象中）： 12345678exports.a = 123;exports.b = 'hello';exports.c = function()&#123; console.log('ccc');&#125;exports.d = &#123; foo : 'bar'&#125; 导出单个成员（拿到的就是：函数、字符串、、、）： 123module.exports = function(x,y)&#123; return x + y;&#125; 下面这个方法同样可以导出多个成员，但是需要重新建立与require的引用关系module.exports = { } 在Node中，每个模块内部都有一个自己的module对象，该module对象中有一个成员叫exports，他也是一个对象，也就是说如果你需要对外导出成员，只需要把导出的成员挂载到module.exports上123456var module = &#123; exports: &#123; foo : 'bar' &#125;&#125;module.exports.foo = 'bar'; 谁来require我，谁就得到module.exports默认在代码的最后有一句：return module.exports我们发现，每次导出接口成员的时候都通过module.exports.xxx = xxx的方式很麻烦。所以，Node为了简化我们的操作，专门提供了一个变量exports等于module.exports,所以在return之前还有一句exports = module.exports 原理解析（exports和module.exports的区别）exports是module.exports的一个引用12console.log(exports === module.exports) // =&gt; trueexports.foo = 'bar' // 等价于 module.exports.foo = 'bar' 每个模块中都有一个module对象 module对象中有一个exports对象 我们可以把需要导出的成员都挂载到module.exports接口对象中 也就是：module.exports.xxx = xxx的方式 但是每次都module.exports.xxx = xxx的方式很麻烦。 所以Node为了方便操作，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports的结果为true 所以对于：module.exports.xxx = xxx的方式完全可以替换为exports.xxx = xxx 当一个模块需要导出单个成员的时候，必须使用：module.exports = xxx的方式 因为每个模块最终向外return的是module.exports 而exports只是module.exports的一个引用 所以即便你为exports重新赋值，也不会影响module.exports 但是有一种赋值方式比较特殊：exports = module.exports这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以灵活运用它第三方模块 art-template 必须通过npm来下载才可以使用什么是模块化 文件作用域 通信规则 加载 require 导出CommonJS模块规范在Node中的JavaScript还有一个重要的概念：模块系统。 模块作用域 使用require方法用来加载模块 使用exports接口对象来导出模块中的成员web服务器开发IP地址和端口号 IP地址用来定位计算机 端口号用来定位具体的应用程序 所有需要联网通信的应用程序都会占用一个端口号 端口号的范围从0 - 65536之间 在计算机中有一些默认端口号，最好不要去使用 例如http服务的80 我们在开发过程中使用一些简单好记的就可以了，例如 3000、5000等 可以同时开启多个服务，但一定要确保不同服务占用不同的端口号才可以 说白了，同一个端口号同一时间只能被一个程序占用 Content-Type（响应内容类型） 在服务端默认发送的数据，其实是utf-8编码的内容，但是浏览器并不知道你是utf-8编码的内容。浏览器在不知道服务器响应内容的编码情况下会按照当前操作系统的默认编码去解析。中文操作系统默认是gbk。解决办法就是告诉浏览器我给你发送的内容是什么编码的response.setHeader(&#39;Content-Type&#39;,&#39;text/plain; charset=utf-8&#39;) 12345678910var http = require('http');var server = http.createServer();;server.on('request',function(request,response)&#123; //设置请求头信息，告诉浏览器用utf-8去解析响应内容 response.setHeader('Content-type','text/plain;charset=utf-8'); response.end('hello,世界');&#125;);server.listen(3000,function()&#123; console.log('Server is runing...');&#125;); text/plain：普通文本 text/html：HTML格式的字符串更多请参考[开源中国contentType对照表]请求对象 Request 响应对象 Response在Node中使用模板引擎模板引擎最早就是诞生于服务器领域，后来才发展到了前端 安装 1npm install art-template 在需要使用的文件模块中加载art-template只需要使用require方法加载就可以了：require(&#39;art-template&#39;)参数中的art-template就是你下载的包的名字也就是说你install的名字是什么，则你require中的就是什么 查文档，使用模板引擎的API 统一处理静态资源服务端渲染留言本 （小案例） 处理留言本案例首页数据列表渲染展示 处理留言本案例发表留言功能 路径 设计好的请求路径 #GET直接或查询字符串数据 Node中需要我们手动解析 url.parse() /pinglun?name=jack&amp;message=hello world split(‘?’) name=jack&amp;messgae=hello world split(‘&amp;’) name=jack message=hello world forEach() name=jack.split(‘=’) 0 key 1 value 掌握如何解析请求路径中的查询字符串 url.parse() 如何在Node中实现服务器重定向 setHeader(‘location’) 301 永久重定向 302 临时重定向 浏览器不会记住 npm node package manager node包管理器npm网站https://www.npmjs.com/npm命令行工具只要安装了node就会自动安装npmnpm也有版本这个概念可以通过在命令行中输入：1npm --version 升级npm1npm install --global npm 常用命令npm常用命令参考链接 npm init npm init -y可以跳过向导，快速生成 npm install 一次性把dependencies选项中的依赖全部安装 npm install 包名 只下载 npm i 简写 npm install --save 包名 下载并且保存依赖项（package.json文件中的dependencies选项） npm uninstall 包名 只删除，如果有依赖项依然保存 npm uninstall --save 包名 删除的同时也会把依赖信息去除 npm un -S 包名 npm help 查看使用帮助 npm 命令 --help 查看指定命令的使用帮助 例如：npm uninstall --help解决npm被墙（下载速度慢）问题npm存储包文件的服务器在国外，有时候会被墙，速度很慢，我们需要解决这个问题 安装淘宝的cnpm12// --global 表示安装到全局，而非当前目录npm insatll --global cnpm 接下来安装包的时候把npm替换成cnpm例子：123//还是通过国外npm服务器，速度比较慢npm insatll jquery//使用cnpm会通过淘宝的服务器来下载jquery 如果不想安装cnpm又想使用淘宝的服务器来下载1npm install jquery --registry=https://registry.npm.taobao.org 但是每次手动添加参数很麻烦，所以可以把这个选项添加到配置文件中：12npm config set registry https://registry.npm.taobao.orgnpm config list 可以查看配置信息 通过上述命令的配置，以后下载所有的包都会通过淘宝镜像来下载。 package.json我们建议每一个项目都要有一个package.json文件（包描述文件，就像产品说明书一样）这个文件可以通过npm init的方式来自动初始化出来对于前端开发者来说，最有用的是那个dependencies选项，可以用来帮我们保存第三方包的依赖信息。 建议执行npm install 包名的时候都加上--save这个选项，目的是为了保存依赖信息。 如果你的node_modules删除了也不用担心，我们只需要：npm install就会自动把package,json中的dependencies中所有的依赖项都下载下来package.json和package-lock.jsonnpm5 以前是不会有package-lock.json这个文件的npm5 之后才加入这个文件当你安装包的时候，npm都会生成或者更新package-lock.json文件ExpressExpress官方网站原生的http在某些方面表现不足以应对我们的开发需求，所以我们就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码高度统一。 第三方web开发框架 高度封装了http模块 更加专注于业务，而非底层细节 知其所以然安装：1npm install --save express hello world1234const express = require('express')const app = express()app.get('/',(req,res) =&gt; res.send('hello world')app.listen(3000,() =&gt; console.log('express app listening on port 3000!')) 基本路由路由 请求方法 请求路径 请求处理函数get：1234//当你以GET方法请求/的时候，执行对应的处理函数app.get('/',function(req,res) &#123; res.send('Hello World!');&#125;); post：1234//当你以POST方法请求/的时候，执行对应的处理函数app.post('/',function(req,res) &#123; res.send('Hello World!');&#125;); 静态服务123456789// /public资源app.use(express.static('public'));// /files资源app.use(express.static('files'));// /public/xxxapp.use('/public'express.static('public'))// /static/xxxapp.use('/static',express.static('public'));app.use('/static',express.static(path.join(__dirname,'public'))); 在Express中配置使用art-template模板引擎github仓库 安装 12npm install --save art-templatenpm install --save express-art-template 配置 1234567var express = require('express'); var app = express(); // 第一个参数用来配置视图的后缀名，这里是art，则你存储在veiws目录中的模板文件必须是xxx.art，我们可以把art改为htmlapp.engine('art',require('express-art-template')); app.set('view options'，&#123; debug：process.env.NODE_ENV！== 'production' &#125;); 配置使用art-template模板引擎第一个参数表示：当渲染以，.art结尾的文件的时候，使用art-template模板引擎express-art-template是专门用来在Express中把art-template整合到Express中虽然外面不需要加载art-template但是也必须安装原因就在于express-art-template依赖了art-template Express为Response响应对象提供了一个方法：renderrender方法默认不可以使用，但是如果配置了模板引擎就可以使用了res.render(&#39;html模板名&#39;,{模板数据})第一个参数不能写路径，默认回去项目中的views目录查找该模板文件也就是说Express有一个约定：开发人员把所有的视图文件都放到views目录中 另外：如果想要修改默认的views目录，则可以使用下面的方法1app.set('views',目录路径) 使用12345678app.get（'/'，function（req，res） &#123; res.render（'index.art'，&#123; user：&#123; name：'aui'， tags：[ 'art'，'template'，'nodejs' ] &#125; &#125;）; &#125;）; 在Express中获取表单GET请求参数Express内置了一个API，可以直接通过req.query来获取1req.query 在Express获取表单POST请求体数据在Express中没有内置获取表单POST请求体的API，所以我们需要借助第三方包：body-parser。 安装： 1npm install --save body-parser 配置： 12345678910111213141516171819var express = require('express')var bodyParser = require('body-parser')var app = express()// parse application/x-www-form-urlencoded/*配置body-parser只要加入了这个配置，则在req请求对象上会多出来一个属性：body也就是说可以直接通过req.body来获取表单POST请求体数据*/app.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json())app.use(function (req, res) &#123; res.setHeader('Content-Type', 'text/plain') res.write('you posted:\n') res.end(JSON.stringify(req.body, null, 2))&#125;) 在Express中配置使用express-session插件 参考文档：https://github.com/expressjs/session 安装 1npm i express-session 配置 12345678//在Express这个框架中，默认不支持Session和Cookie//但是我们可以使用第三方中间件：express-session来解决//该插件会为req请求对象添加一个成员：req.session默认是一个对象app.use(session(&#123; secret: 'keyboard cat', //配置加密字符串，他会在原有加密基础之上和这个字符串拼起来去加密，增加安全性，防止客户端恶意伪造！ resave: false, saveUninitialized: true//无论你是否使用session，都会默认分配一把钥匙。&#125;)) 使用 1234// 添加Session数据req.session.foo = 'bar'// 获取Session数据req.session.foo 提示：默认Session数据时内存存储的，服务器一旦重启就会丢失，真正的生产环境会把Session进行持久化存储。 Express中的路由API路由因为比较多，一般都单独放在一个模块中1234567var express = require('express');//创建路由容器var router = express.Router();//把路由都挂载到router路由容器上router.get('/',function(req,res)&#123;&#125;//把router导出module.exports = router 接下来在入口模块中12345var express = require('express');var router = require('./router');//路由文件var app = express();//把路由容器挂载到app服务中app.use(router); 我们划分模块的目的就是为了增强项目的可维护性，提升开发效率。 中间件 https://expressjs.com/en/guide/using-middleware.html 中间件的本质就是一个请求处理方法，我们把用户从请求到响应的整个过程分发到多个中间件去处理，这样做的目的是提高代码的灵活性，动态可扩展的。 同一个请求所经过的中间件都是同一个请求对象和响应对象应用程序级别中间件万能匹配（不关心任何请求路径和请求方法）： 1234app.use(function(req,res,next)&#123; console.log('Time:',Date.now()) next()&#125;) 仅以/xxx/开头的： 1234app.use('/a',function(req,res,next)&#123; console.log('Time:',Date.now()) next()&#125;) 路由级别中间件get: 123app.get('/',function(req,res)&#123; res.send('Hello World!')&#125;) post:123app.post('/',function(req,res)&#123; res.send('Get a POST request')&#125;) put:123app.put('/user',function(req,res)&#123; res.send('Get a PUT request at /user')&#125;) delete:123app.delete('/user',function(req,res)&#123; res.send('Get a DELETE request at /user')&#125;) 错误处理中间件1234app.use(function(err,req,res,next)&#123; console.error(err.stack) res.status(500).send('Something broke!')&#125;) 内置中间件 express.static() serves static assets such as HTML files, images, and so on. express.json() parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+ express.urlencoded() parses incoming requests with URL-encoded payloads. NOTE: Available with Express 4.16.0+ 第三方中间件 https://expressjs.com/en/resources/middleware.html body-parser session … …增删改查curd案例github项目地址 文件型数据库（锻炼异步编码）起步 初始化 安装依赖 模块处理路由设计请求方法 | 请求路径 | get参数 | post参数 | 备注——– | ——- | ——- | ——- |—-GET | /students | | | 渲染首页GET | /students/new | | | 渲染添加学生页面POST | /students/new | | name,age,gender,hobbies | 处理添加学生请求GET | /students/edit | id | | 渲染编辑页面POST | /students/edit | | id,name,age,gender,hobbies | 处理编辑请求GET | /students/delete | id | | 处理删除请求提取路由模块router.js123456789101112131415161718192021222324252627/*router.js路由模块职责： 处理路由 根据不同的请求方法+请求路径设置具体的请求处理函数模块职责要单一划分模块的目的是为了增强代码的可维护性提高开发效率*/var express = require('express')//1. 创建一个路由容器var router = express.Router()//2. 把路由都挂在到router路由容器中router.get('/students',function(req,res)&#123;&#125;)router.get('/students/new',function(req,res)&#123;&#125;)router.post('/students/new',function(req,res)&#123;&#125;)router.get('/students/edit',function(req,res)&#123;&#125;)router.post('/students/edit',function(req,res)&#123;&#125;)router.get('/students/delete',function(req,res)&#123;&#125;)//3. 把router导出module.exports = router 自己编写的步骤 处理模板 配置开放静态资源 配置模板引擎 简单路由：/students渲染静态页 路由设计 提取路由模块 由于接下来的业务操作都需要处理文件数据，所以我们要封装student.js 先写好student.js文件结构 查询所有学生列表的API find findById save updateById deleteById 实现具体功能 通过路由收到请求 接受请求中的数据（get,post） req.query req.body 通过数据操作API处理数据 根据操作结果给客户端发送响应 业务功能顺序 列表 添加 编辑 删除 MongoDB（芒果数据库）菜鸟教程|MongoDB参考文档 关系型数据库和非关系型数据库表就是关系，或者说表与表之间存在关系 所有的关系型数据库都需要sql语言来操作 所有的关系型数据都在操作之前需要设计表结构 而且数据表还支持约束 唯一的 主键 默认值 非空 非关系型数据库非常的灵活 有的非关系型数据就是key-value键值对 但是MongoDB是长的最像关系型数据库的非关系型数据库 数据库——数据库 数据表——集合（数组） 表记录——文档对象 MongoDB不需要设计表结构 也就是说你可以任意的向里面存数据，没有结构性这个概念MongoDB数据库的基本概念 可以有多个数据库 一个数据库中可以有多个集合（表） 一个集合中可以有多个文档（表记录） 文档结构很灵活，没有任何限制 MongoDB非常灵活，不需要像MySQL一样先创建数据库、表、设计表结构 这里只需要当你需要插入数据的时候，只需要指定往哪个数据库的哪个集合操作就可以了 一切都由MongoDB来自动帮你完成建库建表的事。1234567891011121314&#123; qq:&#123; users:[ &#123;name:'张三1',age:15&#125;, &#123;name:'张三2',age:15&#125;, &#123;name:'张三3',age:15&#125;, &#123;name:'张三4',age:15&#125;, ], products:[], ... &#125; wechat:&#123;&#125; ...&#125; 安装下载MongoDB官网 安装这里不要勾选，其他一路下一步 配置环境变量 鼠标右键选择“计算机”“属性”，会弹出一个框，点击 “高级系统设置”，会弹出一个系统属性，找到环境变量，再点击系统变量里面的Path变量，点击编辑 将MongoDB默认安装路径复制到里面，例如：C:\Program Files\MongoDB\Server\4.0\bin 命令行输入mongod --version出现以下结果就是安装成功。启动和关闭数据库启动：123# mongodb默认使用执行mongod命令所处盘符根目录下的/data/db作为自己的数据存储目录# 所以在第一次执行该命令之前手动新建/data/db目录mongod 如果想要修改默认的数据存储目录，可以：1mongod --dbpath=数据存储目录路径 停止：12在开启服务的控制台，直接Ctrl+c即可停止或者直接关闭控制台 连接和退出数据库连接：12# 该命令默认连接本机的MongoDB服务mongo 退出：12# 在连接状态输入exit退出连接exit 基本命令 查看显示所有数据库 1show dbs 切换到指定的数据库（没有就会创建） 1use 数据库名称 查看当前操作的数据库 1db 查看当前数据库所有的集合 1show collections 插入数据 1db.students.insertOne(&#123;"name":"Jack"&#125;) 查询数据 12# 查询所有students的数据db.students.find() 在Node中如何操作MongoDB数据使用官方的mongodb包来操作MongoDB官方驱动包 使用第三方mongoose操作MongoDB数据库第三方包：mongoose基于MongoDB官方的mongodb包再一次做了封装mongoose官网mongoose官方API文档 起步1npm i mongoose hello world1234567const mongoose = require('mongoose');mongoose.connect('mongodb://localhost:27017/test', &#123;useNewUrlParser: true&#125;);const Cat = mongoose.model('Cat', &#123; name: String &#125;);const kitty = new Cat(&#123; name: 'Zildjian' &#125;);kitty.save().then(() =&gt; console.log('meow')); 官方指南 设计Schema发布Model 1234567891011121314151617181920212223242526272829303132333435var mongoose = require('mongoose');var Schema = mongoose.Schema;//1. 连接数据库，指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来mongoose.connect('mongodb://localhost/demo1');/*2. 设计文档结构（表结构）字段名称就是表结构中的属性名称约束的目的就是为了保证数据的完整性，不要有脏数据*/var userSchema = new Schema(&#123; username: &#123; type:String, required: true//必须有 &#125;, password: &#123; type: String, required: true &#125;, email: &#123; type: String &#125;&#125;);/*3. 将文档结构发布为模型 mongoose.model方法就是将一个架构发布为model 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称 mongoose会自动将大写名词的字符串生成小写复数的集合名称 例如这里的User最终会变为users集合名称 第二个参数：Schema 返回值： 模型构造函数*/ var User = mongoose.model('User',userSchema);/*4. 当我们有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据为所欲为了(增删改查)*/ 增加数据 12345678910111213var admin = new User(&#123; username: 'admin', password: '123456', email: 'admin@admin.com'&#125;);admin.save(function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else&#123; console.log('ok') console.log(ret) &#125;&#125;); 查询数据 123456789101112131415161718 // 查询User.find(/*&#123;name: 'admin'&#125;,查找所有符合条件的，不加就是查询所有*/function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else &#123; console.log(ret) &#125;&#125;)// 按条件查询单个数据User.findOne(&#123; username: 'admin', password: '123456'&#125;,function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else &#123; console.log(ret) &#125;&#125;) 删除数据 123456789User.remove(&#123; username: 'admin'&#125;,function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else &#123; console.log('ok') &#125;&#125;); 更新数据 1234567891011121314// 根据条件更新所有：Model.update(conditiions,doc,[options],[callback]);// 根据指定条件更新一个：Model.findOneAndUpdate([conditions],[update],[options],[callback]);// 根据id更新一个User.findByIdAndUpdate('50dfd4535500df00554gf',&#123; password: '123'&#125;,function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else &#123; console.log('ok') &#125;&#125;) 其他修改完代码自动重启服务器我们这里可以使用一个第三方工具：nodemon来帮我们解决频繁修改代码重启服务器的问题。nodemon是一个基于Node.js开发的一个第三方命令行工具，我们使用的时候需要独立安装：1npm install --global nodemon 安装完毕之后，使用：123不用再使用node xx.js命令使用nodemonnodemon xxx.js 只要是通过nodemon启动的服务，它会监视你的文件变化，当文件发生变化，会自动重启服务器。 文件操作路径和模块路径文件操作路径：1234567891011121314/*在文件操作的相对路径中 ./data/a.txt 相对于当前目录 data/a.txt 相对于当前目录 /data/a.txt 绝对路径，当前文件模块所处磁盘根目录 c:/xx/xxx... 绝对路径 fs.readFile('./data/a.txt',function(err,data)&#123; if(err)&#123; console.log(err) return console.log('读取失败') &#125; console.log(data.toString)()) &#125;)*/ 模块操作路径：12345//这里如果忽略了，则也是磁盘根目录require('/data/foo.js')//相对路径require('.data/foo.js')//模块加载的路径中的相对路径不能省略 ./ 注：Node不适合从来没有接触过服务端的人学习如果想要真正的学好服务端，还是老牌的java、PHP这些平台node不是特别适合入门服务端，但不代表node不强大node很厉害，具有经验的人可以玩的非常牛不适合新手的原因就是在于偏底层、而且太灵活java、PHP好入门的原因就在于：这些平台屏蔽了一些底层]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git和GitHub的基本使用]]></title>
    <url>%2F2018%2F03%2F17%2FGit%E5%92%8CGitHub%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[GIT什么是Git 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 让源代码可以被追溯，主要记录每次变更了什么。 人为维护比较麻烦 Git是Linux之父为了维护管理Linux的源代码写的一个工具 Git 之前很多实用SVN vss tfs hs 。。。 安装Git Git命令行工具 基于Git命令行的一个客户端软件（提供一个界面去管理源代码） Git命令操作初始化一个本地Git仓储12cd 当前项目目录git init // 初始化一个本地仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录项目的变更信息 查看本地仓储的变更状态 git status 第一次查看，显示的是一坨没有被跟踪的变化 git status -s 列出更详细的信息 添加本地暂存（托管）文件1git add 可以将一个没有被跟踪的文件添加到跟踪列表 类似于node_modules这种性质的文件是不应该被跟踪的 添加本地忽略清单 在代码库文件夹的根目录添加一个.gitignore文件 此文件用于说明忽略的文件有哪些 由于Windows下不知直接建以” . “开头的文件，必须键入文件名才可以，所以应该使用命令行创建上面这个文件夹 123echo '' &gt; .gitignore//下面这种是文件夹格式的mkdir .gitignore 里面写上文件名即可（支持通配符） /dist: 表示根目录下dist被禁止。 提交被托管的文件变化到本地仓储12git commit -m '第一次提交'//将本地的变化提交到本地的仓库文件夹归档 后面需要加上 -m ‘信息（如第一次提交或者修改了什么文件，第二次提交）’ 一般在有了一个小单元的整体变化后再提交 对比差异1git diff //difference差异 查看提交日志1git log ### 回归到指定版本1 git reset --hard //后面跟上对应版本的哈希值前六位 查看所有命令1git help GitHub基本使用 https://github.com/ GitHub是一个git服务的提供商 提出了社交化编程 添加一个远端的地址12git remote add origin 远端地址git remote -v //查看地址 推送到远端123git push -u origin master//-u是以流的方式上传，速度比较快，可以不加。//master是主分支 从远端拉回1git pull origin master 分支 查看当前分支 1git branch 创建一个分支 1git branch v2(分支名) 切换分支 1git checkout v2 创建分支之后需要继续推到远端仓库git push -u origin v2 特殊的分支（网页预览）12git branch gh-pages//名字必须为gh-pages才可变成网页 如果需要绑定域名需要在对应仓库下建立CNAME文件，里面写上域名。前提是需要做dns解析!克隆仓库1git clone 远端地址]]></content>
      <categories>
        <category>git和github</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（笔记）]]></title>
    <url>%2F2018%2F01%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[RegExpw3school: http://www.w3school.com.cn/js/jsref_obj_regexp.asp 正则表达式的作用： 匹配特殊字符或有特殊搭配原则的字符串的最佳选择。 两种创建方式 推荐使用 1var reg = /abc/; 例：123var reg = /abc/i //i ignoreCase 忽视大小写var reg = /abc/m //m 执行多行匹配var reg = /abc/ g // g global 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） new RegExp( ) 1var reg = new RegExp() 正则表达式方法 compile : 编译正则表达式。 exec : 检索字符串中指定的值。返回找到的值，并确定其位置。 test : 检索字符串中指定的值。返回 true 或 false。支持正则的字符串方法 search ： 检索与正则表达式相匹配的值。 match : 找到一个或多个正则表达式的匹配 replace：替换与正则表达式匹配的子符串。 split：把字符串分割为字符串数组方括号（摘自w3school）元字符（摘自w3school）量词（摘自w3school）例题1234var str = "100000000";var reg = /(?=(\B)(\d&#123;3&#125;)+$)/g;console.log(str.replace(reg,"."));//输出结果为：100.000.000]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
</search>
