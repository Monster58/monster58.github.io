<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack入门]]></title>
    <url>%2F2019%2F03%2F17%2Fwebpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[webpack中文文档webpack官网 了解webpack相关什么是webpack webpack是一个模块打包器（bundler） 在webpack看来，前端所有的资源文件（js/json/css/img/less/…）都会作为模块处理 它将根据模块的依赖关系进行静态分析，生成对应的静态资源理解loader webpack本身只能加载JS/JSON模块，如果要加载其他类型的文件（模块），就需要使用对应的loader进行转换/加载 loader本身也是运行在node.js环境中的javascript模块 它本身是个函数，接受源文件作为参数，返回转换得结果 loader一般以xxx-loader的方式命名，xxx代表了这个loader需要做的转换功能，比如json-loader配置文件（默认） webpack.config.js是一个node模块，返回一个json格式的配置信息对象插件 插件可以完成一些loader不能完成的功能。 插件的使用一般是在webpack的配置信息plugins选项中指定。 CleanWebpackPlugin： 自动生成HTML文件 UgligyJSPlugin: 压缩js文件安装webpack12345# 全局安装# 不推荐全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，可能会导致构建失败。npm install webpack -g# 局部安装npm install webpack --save-dev 如果你使用 webpack 4+ 版本，你还需要安装 CLI。 1npm install --save-dev webpack-cli 编译打包应用 创建入口src/js/entry.js 创建主页面dist/index.html &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 编译js 1webpack src/js/entry.js dist/bundle.js 添加js/json文件 创建第二个js: src/js/math.js 1234567export function square(x) &#123; return x * x;&#125;export function cube(x) &#123; return x * x * x;&#125; 创建json文件: src/json/data.json 1234&#123; "name": "Tom", "age": 12&#125; 更新入口js : entry.js 123456import &#123;cube&#125; from './math'import data from '../json/data.json'//注意data会自动被转换为原生的js对象或者数组document.write("entry.js is work &lt;br/&gt;");document.write(cube(2) + '&lt;br/&gt;');document.write(JSON.stringify(data) + '&lt;br/&gt;') 编译js: 1webpack src/js/entry.js dist/bundle.js 使用webpack配置文件 根目录下创建webpack.config.js文件 123456789const path = require('path'); //path内置的模块，用来设置路径。module.exports = &#123; entry: './src/js/entry.js', // 入口文件 output: &#123; // 输出配置 filename: 'bundle.js', // 输出文件名 path: path.resolve(__dirname, 'dist') //输出文件路径配置 &#125;&#125;; 配置npm命令package.json123"scripts": &#123; "build": "webpack" &#125;, 打包应用1npm run build 打包css和图片文件 安装样式的loader 123npm install css-loader style-loader --save-devnpm install file-loader url-loader --save-dev#补充：url-loader是对象file-loader的上层封装，使用时需配合file-loader使用。 大图无法打包到entry.js文件中，index.html不在生成资源目录下。页面加载图片会在所在目录位置查找，导致页面加载图片时候大图路径无法找到解决办法： 1. 使用publicPath : &apos;dist/js/&apos; //设置为index.html提供资源的路径,设置完后找所有的资源都会去当前目录下找。 将index.html放在dist/js/也可以解决。 自动编译打包 利用webpack开发服务期工具webpack-dev-server 下载 1npm install --save-dev webpack-dev-server webpack.config.js配置 123devServer:&#123; contentBase: './dist'&#125;, package.json配置 1"start": "webpack-dev-server --open" 编译打包应用并运行 1npm start 使用webpack插件 常用的插件 使用html-webpack-plugin根据模板html生成引入script的页面 使用clean-webpack-plugin清除dist文件夹 下载 1npm insatll --save-dev html-webpack-plugin clean-webpack-plugin webpack.config.js配置 123456const HtmlWebpackPlugin = require('html-webpack-plugin'); //自动生成html文件的插件const CleanWebpackPlugin = require('clean-webpack-plugin'); //清除之前打包的文件 plugins: [ new HtmlWebpackPlugin(&#123;template: './index.html'&#125;), new CleanWebpackPlugin(['dist']),] 打包运行项目 12npm run buildnpm start]]></content>
  </entry>
  <entry>
    <title><![CDATA[什么是MVVM]]></title>
    <url>%2F2019%2F03%2F17%2F%E4%BB%80%E4%B9%88%E6%98%AFMVVM%2F</url>
    <content type="text"><![CDATA[特点： 针对具有复杂交互逻辑的前端应用 提供基础的架构抽象 通过Ajax数据持久化，保证前端用户体验市面上几个主流的MVVM框架 AngularJS reactJS VueJS数据驱动数据响应原理数据（model）改变驱动视图（view）自动更新组件化扩展HTML元素，封装可重用的代码组件设计原则 页面上每个独立的可视/可交互区域视为一个组件 每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护 页面不过是组件的容器，组件可以嵌套自由组合形成完整的页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[查看npm全局安装的模块]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%9F%A5%E7%9C%8Bnpm%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E7%9A%84%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1npm list -g --depth 0]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS模块化]]></title>
    <url>%2F2019%2F01%2F17%2FJS%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起，这就是JS模块化。块的内部数据/实现是私有的，只是向外暴露一些接口（方法）与外部其他模块通信。 模块化规范CommonJS规范说明 每个文件都可当做一个模块 在服务器端：模块的加载是运行时同步加载的 在浏览器端：模块需要提前编译打包处理基本语法暴露模块 module.exports = value exports.xxx = value引入模块require(xxx)第三方模块、系统模块xxx为模块名自定义模块xxx为模块文件路径实现服务端实现Node.js浏览器端实现Browserify也称为CommonJS的浏览器端的打包工具Browserify模块化使用教程 创建目录结构 123456789|- js |- dist // 打包生成文件的目录 |- src // 源码所在的目录 |- module1.js |- module2.js |- module3.js |- app.js // 应用主源文件|- index.html|- package.json 下载browserify 全局安装 1npm install browserify -g 局部安装 1npm install browserify --save-dev 打包处理js 12browserify js/src/app.js -o js/dist/bundle.js # -o output输出 前面是要打包的文件，后面是输出后的位置及文件名 AMD规范说明 Asynchronous Module Definition（异步模块定义） https://github.com/amdjs/amdjs-api/wiki/AMD 专门用于浏览器端，模块的加载是异步的基本语法定义暴露模块 123456789//定义没有依赖的模块define(function()&#123; return 模块&#125;)//定义有依赖的模块define(['module1','module2'],function(m1,m2)&#123; return 模块&#125;) 引入使用模块123require(['moudle1','moudle2'],function(m2,m2)&#123; 使用m1/m2&#125;) 实现（浏览器端） Require.js http://www.requirejs.cn/ http://www.ruanyifeng.com/blog/2012/11/require_js.htmlrequire.js使用教程 下载require.js ，并引入 js/libs/require.js 创建项目结构 12345678|-js |- libs |- require.js |- modules |- modules1.js |- modulew2.js |- main.js|- index.html 定义require.js的模块代码 应用主(入口)js: main.js 12345678910111213141516171819202122232425262728293031(function () &#123; //配置 require.config(&#123; //基本路径 baseUrl: 'js/', //映射: 模块标识名: 路径 paths: &#123; //自定义模块 'alerter': 'modules/alerter', 'dataService': 'modules/dataService', //库模块 'jquery': 'libs/jquery-1.10.1', 'angular': 'libs/angular' &#125;, //配置不兼容AMD的模块 shim: &#123; angular: &#123; exports: 'angular' &#125; &#125; &#125;) //引入模块使用 require(['alerter', 'angular'], function (alerter, angular) &#123; alerter.showMsg() console.log(angular); &#125;)&#125;)() 引入require.js并指定js主文件的入口 1&lt;script type="text/javascript" src="js/libs/require.js" data-main="js/main.js"&gt;&lt;/script&gt; CMD（了解）规范说明 Common Module Definition（通用模块定义） https://github.com/seajs/seajs/issues/242 专门用于浏览器端，模块的加载是异步的 模块使用时才会加载执行基本语法定义暴露模块 12345678910111213141516//定义没有依赖的模块define(function(require,exports,module)&#123; exports.xxx = value module.exports = value&#125;)//定义有依赖的模块define(function(require,exports,module)&#123; //引入依赖模块（同步） var module2 = require('./module2') //引入依赖模块（异步） require.async('./module3',function(m3)&#123; &#125;) //暴露模块 exports.xxx = value&#125;) 引入使用模块123456define(function(require)&#123; var m1 = require('./module1') var m4 = require('./module4') m1.show() m4.show()&#125;) 实现（浏览器端） Sea.js http://www.zhangxinxu.com/sp/seajs 12345678910111213141516&lt;!--使用seajs: 1. 引入sea.js库 2. 如何定义导出模块 : define() exports module.exports 3. 如何依赖模块: require() 4. 如何使用模块: seajs.use()--&gt;&lt;script type="text/javascript" src="js/libs/sea.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; seajs.use('./js/modules/main')&lt;/script&gt; ES6*规范说明 http://es6.ruanyifeng.com/#docs/module 依赖模块需要编译打包处理 语法 导出模块：export 引入模块：import xxx from &#39;路径&#39;实现（浏览器端） 使用Babel将ES6编译为ES5代码 使用Browserify编译打包jsES6-Babel-Browserify使用教程 安装babel-cli,babel-preset-es2015和browserify 12npm install babel-cli browserify -gnpm install babel-preset-es2015 --save-dev 定义.babelrc文件 123&#123; "presets": ["es2015"]&#125; 定义.babelrc文件 123&#123; "presets":["es2015"]&#125; 编码 js/src/module1.js 分别暴露 1234567export function foo() &#123; console.log('module1 foo()');&#125;export function bar() &#123; console.log('module1 bar()');&#125;export const DATA_ARR = [1, 3, 5, 1] js/src/module2.js 统一暴露 1234567891011let data = 'module2 data'function fun1() &#123; console.log('module2 fun1() ' + data);&#125;function fun2() &#123; console.log('module2 fun2() ' + data);&#125;export &#123;fun1, fun2&#125; js/src/module3.js默认暴露 123456export default &#123; name: 'Tom', setName: function (name) &#123; this.name = name &#125;&#125; js/src/app.js 12345678910111213141516import &#123;foo, bar&#125; from './module1'import &#123;DATA_ARR&#125; from './module1'import &#123;fun1, fun2&#125; from './module2'import person from './module3'import $ from 'jquery'$('body').css('background', 'red')foo()bar()console.log(DATA_ARR);fun1()fun2()person.setName('JACK') 编译 使用Babel将ES6编译为ES5代码(但包含CommonJS语法) : babel js/src -d js/lib 使用Browserify编译js : browserify js/lib/app.js -o js/lib/bundle.js 页面中引入测试 1&lt;script type="text/javascript" src="js/lib/bundle.js"&gt;&lt;/script&gt; 引入第三方模块(jQuery) 下载jquery模块 在app.js中引入并使用12import $ from 'jquery'$('body').css('background', 'red')]]></content>
  </entry>
  <entry>
    <title><![CDATA[配置browser-sync浏览器同步测试工具]]></title>
    <url>%2F2018%2F07%2F17%2F%E9%85%8D%E7%BD%AEbrowser%E2%80%94-sync%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%AD%A5%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[BrowserSync是基于Node.js的, 是一个Node模块， 如果想要使用它，需要先安装一下Node.js 官方网站：https://browsersync.io/中文参考网站：http://browsersync.cn/ 安装全局安装12#简写方式：npm i -D browser-syncnpm install -g browser-sync 在项目中安装1npm install --save-dev browser-sync 在项目中配置scripts在项目的包描述文件中插入以下代码1234"scripts":&#123; "dev": "browser-sync start --server --files \"*.html, css/*.css, js/\"", "start": "npm run dev" &#125; 启动项目在命令行中输入以下，即可启动项目 1npm start]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6笔记]]></title>
    <url>%2F2018%2F06%2F17%2FES6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 入门 阮一峰 著 常用 let和const关键字let作用与var类似，用于声明一个变量 特点 在块级作用域有效 不能重复声明 不会预处理，不存在变量提升应用： 循环遍历加监听 使用let取代var是趋势const作用 定义一个常量特点 不能修改（引用值可以改变） 其他特点同let应用 保存不用更改的数据变量的解构赋值理解：从对象或数组中提取数据，并赋值给变量（多个）对象的解构赋值 1let &#123;n,a&#125; = &#123;n:'tom',a:12&#125; 数组的解构赋值1let [a,b] = [1,'abc'] 用途给多个形参赋值 EX：123456789101112131415161718//ES5var obj = &#123;userName:'tom',lastName:'li'&#125;var userName = obj.userName;var lastName = obj.lastName;//ES6let obj = &#123;userName:'tom',lastName:'li'&#125;let &#123;userName,lastName&#125; = objconsole.log(userName,lastName)let arr = [1,3,5,'abc',true];let [,,a,b] = arr;console.log(a,b)//为形参赋值function foo (&#123;userName,lastName&#125;)&#123; console.log(userName,lastName)&#125;foo(obj) 模板字符串作用：简化字符串的拼接 语法模板字符串必须写在两个`（反引号）里面，变化部分使用${xxx}`定义 123let name = 'tom'let age = 13console.log(`my name is $&#123;name&#125;,my age is $&#123;age&#125;`) 简化的对象写法 省略同名的属性值 省略方法的function 123456let x = 1;let y = 2;let point = &#123; x, y, set(x) &#123;this.x = x&#125; 箭头函数 箭头函数特点： 简洁 箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是定义的时候处在的对象就是他的this 扩展理解： 箭头函数的this看外层是否有函数， 如果有，外层函数的this就是内部箭头函数的this， 如果没有，this就指向window形参的情况123456789//1. 没有形参的时候 必须有（）let fun = () =&gt; console.log('我是箭头函数');fun();//2. 只有一个形参的时候（） 可以省略let fun1 = a =&gt; console.log(a)fun1('hehe');//3. 两个及两个以上 （） 不能省略let fun2 = (a,b,c,...) =&gt; console.log(x,y);fun2() 函数体的情况12345678910//1. 函数体只有一条语句或者是表达式 &#123;&#125; 可以省略----&gt;会自动返回语句执行结果或者是表达式的结果。let fun3 = (x,y) =&gt; x + y;console.log(fun3(1,3))// 2. 函数体不止一条语句或者是表达式的情况 &#123;&#125; 不可以省略let fun4 = (x,y) =&gt; &#123; console.log(x,y); //需要手动返回 return x + y;&#125;;console.log(fun4(35,49)); 点点点运算符用途 rest（可变）参数 用来取代arguments 但比arguments灵活，只能是最后部分形参参数（如果...value前面还有形参，那么...value就是剩下的形参，而且...value只能放到最后面 ） 123456789101112function fun(...value) &#123; console.log(arguments); //arguments是伪数组，没有forEach方法，所以下面会报错 /*arguments.forEach(function(item, index) &#123; console.log(item, index); &#125;)*/ console.log(value); value.forEach(function(item, index) &#123; console.log(item, index); &#125;)&#125;fun(1,2,3,3) 扩展运算符 1234let arr1 = [2,3,4,5];let arr2 = [1,...arr1,6];console.log(arr2);// ====&gt; [1,2,3,4,5,6] 形参默认值当不传入参数的时候默认使用形参里的默认值 12345678function Point(x=1,y=2)&#123; this.x = x; this.y = y;&#125;let point = new Point()console.log(point)let point2 = new Point(3,4)console.log(point2) 输出结果： Promise对象理解： Promise对象：代表了未来某个将要发生的事件（通常是一个异步操作） 有了promise对象，可以将异步操作以同步的流程表达出来，避免回调地狱 ES6的Promise是一个构造函数，用来生成promise实例使用promise基本步骤（2步）1234567891011121314// 创建promise对象let promise = new Promise((resolve,reject) =&gt; &#123; //初始化promise状态为pending //执行异步操作 if(异步操作成功)&#123; resolve(value);//修改promise的状态为fullfilled &#125; else &#123; reject(errMsg);//修改promise状态W为rejected &#125;&#125;)// 调用promise的then()promise.then(function(result =&gt; console.log(result),errorMsg =&gt; alert(errorMsg))) promise对象的三个状态 pending： 初始化状态 fullfilled： 成功状态 rejected： 失败状态应用： 使用promise实现超时处理 使用promise封装处理Ajax请求 12345let request = new XMLHttpRequest();request.onreadystatechange = function()&#123;&#125;request.responseType = 'json';request.open("GET",url);request.send(); Symbol ES5中对象的属性名都是字符串，容易造成重名，污染环境 概念：ES6中的 添加了一种原始数据类型symbol 特点： Symbol属性对应的值是唯一的 Symbol值不能与其他数据进行计算，包括同字符串拼串 for in，for of遍历时不会遍历symbol属性使用： 调用Symbol函数得到symbol值 123let symbol = Symbol();let obj = &#123;&#125;;obj[symbol] = 'hello'; 传参标识 1234let symbol = Symbol('one');let symbol2 - Symbol('two');console.log(symbol);//Symbol('one')console.log(symbol2);//Symbol('two') 内置Symbol值 除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部的使用方法。 Symbol.iterator 对象的Symbol.iterator属性，指向该对象的默认遍历器方法Iterator遍历器概念：Iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制作用： 为各种数据结构，提供统一的、简便的访问接口 使得数据结构的成员能够按某种次序排列 ES6创造了一种新的遍历命令for...of循环，Iterator接口机制主要供for...of消费工作原理 创建一个指针对象（遍历器对象），指向数据结构的起始位置。 第一次调用next方法，指针自动指向数据结构的第一个成员 接下来不断调用next方法，指针会一直往后移动，知道指向最后一个成员 每调用next方法返回的是一个包含value和done的对象，value：当前成员的值，done：布尔值 value表示当前成员的值，done对应的布尔值表示当前的数据结构是否遍历结束。 当遍历结束的的时候返回的value 的值是undefined,done值为false 原生具备iterator接口的数据（可用for of遍历） 扩展理解 当数据结构上部署了Symbol.iterator接口，该数据就是可以用for of遍历Generator函数概念： ES6提供的解决异步编程的方案之一 Generator函数是一个状态机，内部封装了不同状态的数据 用来生成遍历器对象 可暂停函数（惰性求值），yield可暂停，next方法可启动。每次返回的是yield后的表达式结果。特点： function与函数名之间有一个*号 内部用yield表达式来定义不同的状态 例如： 1234function* generatorExample()&#123; let result = yield 'hello'; // 状态值为hello yield 'generator'; // 状态值为generator&#125; generator函数返回的是指针对象,而不会执行函数内部逻辑。 调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yiedl后的表达式结果/undefined，done: true/false} 再次调用next方法会从上一次停止时的yield处开始，直到最后 yield语句返回结果通常为undefined，当调用next方法时传参内容会作为启动时yield语句的返回值。async函数（源自ES2017）概念：真正意义上去解决异步回调的问题，同步流程表达异步操作本质Generator的语法糖语法： 1234async function foo()&#123; await 异步操作; await 异步操作;&#125; 特点： 不需要像Generator去调用next方法，遇到await等待，当前的异步操作完成就会往下执行。 返回的总是Promise对象，可以用then方法进行下一步操作 async取代Generator函数的*号，await取代Generator的yield 语义上更为明确，使用简单。class 通过class定义类/实现类的继承 在类中通过constructor定义构造方法 通过new 来创建类的实例 通过extends类的继承 通过super调用父类的构造方法 里面必须用对象的简写方法 123456789101112131415161718192021222324252627282930//定义一个人物的类//父类class Person &#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; //类的一般方法 sayHi()&#123; console.log('hi'); &#125;&#125;let person = new Person('jack',23);console.log(person);person.sayHi(); // hi//子类class StarPerson extends Person&#123; constructor(name,age,salary)&#123; super(name,age);//调用父类的构造方法 this.salary = salary; &#125; //父类的方法重写，没有的话实例会向上找到父类的方法 sayHi()&#123; console.log('hello') &#125;&#125;let p1 = new StarPerson('tom',34,120000)console.log(p1);p1.showName();// hello 其他 字符串扩展 includes(str) 判断是否包含指定的字符串 123let str = 'sagkajsgjgsjg';console.log(str.includes('t'))//falseconsole.log(str.includes('s'))//true startsWith(str) 判断是否以指定字符串开头 1console.log(str.startsWith('sa'))//true endsWith(str) 判断是否以指定字符串结尾 1console.log(str.endsWith('g'))//true repeat(count) 重复指定次数 12let str = 'abc';console.log(str.repeat(3))//abcabcabc padStart(maxLength,fillstring=&#39;&#39;)从首位填充字符串 1234//例如处理时间的情况，日期为单数则前面加一个0let date = new Date()let Month = date.getMonth()Month.toString().padStart(2,'0') // 0X padEndt(maxLength,fillstring=&#39;&#39;)从末位填充字符串数值的扩展 二进制与八进制数值表示法：二进制用0b，八进制用0o 12console.log(0b1010);//10console.log(0o56);//46 Number.isFinite(i) 判断是否是有限大的数，Infinity无穷大 Number.isNaN(i) 判断是否是NaN Number.isInteger(i) 判断是否是整数 Number.parseInt(str) 将字符串转换为对应的数值 Math.trunc(i) 直接去除小数部分数组的扩展 Array.from(v) 将伪数组对象或可遍历对象转换为真数组 1234let btns = document.getElementsByTagName('button');//伪数组Array.form(btns).forEach(function(item,index)&#123; console.log(item);&#125;) Array.of(v1,v2,v3) 将一系列数值转换为数组 12let arr = Array.of(1,34,6,'ba',true);console.log(arr); //[1,34,6,'ba',true] find(function(value,index,arr){return true})找出第一个满足条件返回true的元素 123456let arr = [1,2,3,4,5];let result = arr.find(function(item,index)&#123; return item &gt; 2&#125;)console.log(result)//3 findIndex(function(value,index,arr){return true}) 找出第一个满足条件返回true的元素的下标 123456let arr = [1,2,3,4,5];let result = arr.findIndex(function(item,index)&#123; return item &gt; 2&#125;)console.log(result)//2 Object扩展 Object.is(v1,v2) 判断2个数据是否完全相等（以字符串形式判断） Object.assign(target,source1,source2..) 将源对象的属性复制到目标对象上 12345let obj = &#123;&#125;;let obj1 = &#123;username: 'jack',age: 23&#125;let obj2 = &#123;sex: 1&#125;console.log(Object.assign(obj,obj1,obj2))// &#123;username: 'jack',age: 23,sex: 1&#125; 直接操作__proto__属性 12let obj2 = &#123;&#125;;obj2.__proto__ = obj1; 深度克隆拷贝数据 基本数据类型： 拷贝后会生成一份新的数据，修改拷贝后的数据不会影响原数据 对象/数组 拷贝后不会生成新的数据，而是引用。修改拷贝后的数据会影响原来的数据 直接赋值给一个变量 浅拷贝 Object.assign() 浅拷贝 Array.prototype.concat() 浅拷贝 Array.prototype.slice() 浅拷贝 JSON.parse(JSON.stringify()) 深拷贝（深度克隆），拷贝的数据里不能有函数，处理不了。Set容器和Map容器Set容器：无序不可重复的多个value的集合体 Set() Set(array) add(value) delete(value) has(value) clear() size 1let set = new Set([1,2,3,4,5]) Map容器：无序的key不重复的多个key-value的集合体 Map() Map(array) set(key,value) //添加 get(key) delete(key) has(key) clear() size 12//以二位数组的形式传入多个key-valuelet map = new Map([['key','value'],[23,'age']]) ES7 ES7正式发布的 指数运算符（幂）：** 1console.log(3 ** 3) // 27 Array.prototype.includes(value) 判断数组中是否包含指定value]]></content>
  </entry>
  <entry>
    <title><![CDATA[node.js入门和使用]]></title>
    <url>%2F2018%2F05%2F17%2Fnode.js%E5%85%A5%E9%97%A8%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[nodejs是什么 Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js不是一门语言 Node.js不是库、不是框架 是一个JavaScript运行时环境 简单来讲就是Node.js可以解析和执行JavaScript代码 以前只有浏览器可以解析JavaScript代码 现在JavaScript可以完全脱离浏览器来执行，一切都归功于：Node.js 浏览器中的JavaScript ECMAScript 基本语法 if var function Object Array BOM DOM Node.js中的JavaScript 没有BOM、DOM ECMAScript 在node这个js执行环境中为JavaScript提供了一些服务器级别的操作API 例如文件读写 网络服务的构建 网络通信 http服务器 等处理、、、、 构建与chrome浏览器v8引擎之上 代码只是具有特定格式的字符串 引擎可以认识他，可以帮你去解析和执行 Google Chrome的v8引擎是目前公认的解析执行JavaScript代码最快的 Node.js的作者把Google Chrome中的V8引擎移植了出来，开发了一个独立的JavaScript运行时环境。 Node.js uses an event-driven,non-blocking I/O model that makes it lightweight and efficient. event-driven 事件驱动 non-blocking I/O model 非阻塞IO模型（异步） lightweight and efficient. 轻量和高效 Node.js package ecosytem,npm,is the largest ecosystem of open source libraries in the world npm是世界上最大的开源库生态系统 绝大多数JavaScript相关的包都存放在npm上，这样做的目的是为了让开发人员更方便的去下载使用。 npm install jquery Node.js可以做什么 web服务器后台 命令行工具 npm（node） git（c语言） hexo（node） 。。。 对于前端开发工程师来讲，接触node最多的是他的命令行工具 自己写的很少，主要是使用第三方开发的 webpack gulp npm预备知识 HTML css JavaScript 简单的命令行操作 具有服务端开发经验更佳一些资源 《深入浅出Node.js》 朴灵 偏理论，几乎没有任何实战性内容 理解原理底层有帮助 《Node.js权威指南》 API讲解 没有业务，没有实战 JavaScript标准参考教程（alpha）： https://wangdoc.com/javascript/ Node入门： http://www.nodebeginner.org/index-zh-cn.html 官方API文档： https://nodejs.org/dist/latest-v6.x/docs/api/ CNODE社区：http://cnodejs.org CNODE-新手入门： http://cnodejs.org/getstart可以学到什么 B/S编程模型 Browser-Server back-end 任何服务端技术这种BS编程模型都是一样，和语言无关 Node只是我们学习BS编程模型的的一个工具而已 模块化编程 RequireJS SeaJS @import(&#39;文件路径&#39;) 以前认知的的JavaScript只能通过script标签来加载 在Node中可以像@import ()一样来引用加载JavaScript脚本文件 Node常用API 异步编程 回调函数 Promise async generator Express Web开发框架 学习node不仅会帮助大家打开服务端黑盒子，同时会帮助你学习前端高级内容 Vue.js React angular 起步安装Node环境 查看当前Node环境的版本号node --version 环境变量REPL read 读取 eval 执行 print 输出 loop 循环在终端输入node命令直接敲回车这个环境的作用只是用来帮助我们做一些辅助测试，例如在里面可以直接使用node中的核心模块而不需要require加载。HelloWorld 创建编写JavaScript脚本文件 打开终端，定位到脚本文件所属目录 输入node文件名执行对应文件注意： 文件名不要使用node.js来命名！ 解析执行JavaScript 读写文件 浏览器中的JavaScript是没有文件操作的能力的 但是Node中的JavaScript具有文件操作的能力 fs是file-system的简写，就是文件系统的意思 在Node中如果想要进行文件操作，就必须引入fs这个核心模块 在fs这个核心模块中，就提供了所有的文件操作相关的API 例如：fs.readFile就是用来读取文件的 使用require方法加载fs核心模块1234567891011121314151617181920212223// 1.使用require方法加载fs核心模块var fs = require('fs');/* 2.读取文件第一个参数是要读取的文件路径第二个参数就是一个回调函数 成功 data 数据 error null 失败 data null error 错误对象*/fs.readFile('data/readfile.txt',function(error,data)&#123; // console.log(data); console.log(data.toString());/* &lt;Buffer 68 65 6c 6c 6f 20 6e 6f 64 65 6a 73 0d 0a e4 bd a0 e5 a5 bd 20 6e 6f 6465 6a 73&gt;文件中存取的其实都是二进制数据这里为什么看到的不是0和1呢？原因是二进制转为了16进制但是无论是二进制还是16进制，人类都不认识所以可以通过toString方法转为我们能认识的字符*/&#125;); 创建http服务 我们可以使用Node非常轻松的构建一个web服务器 在Node中专门提供了一个核心模块：http http这个模块的职责就是帮你创建编写服务器的1234567891011121314151617181920//1.加载http核心模块var http = require('http');//2.使用http.createServer()方法创建一个web服务器// 返回一个Server实例var server = http.createServer();//3.服务器要干嘛// 提供服务：对数据的服务// 发送请求// 接受请求// 处理请求// 发送响应//3.绑定端口号，启动服务器server.listen(3000,function()&#123; console.log('服务器启动成功，通过http://127.0.0.1:3000/ 进行访问');&#125;);// 4.注册request请求事件// 当客户端请求过来，就会自动触发request请求事件，然后执行第二个参数（回调函数） server.on('request',function()&#123; console.log('接收到客户端请求');&#125;); request请求处理函数 12345678910111213141516171819202122var http = require('http');var server = http.createServer();server.listen(3000,function()&#123; console.log('服务器启动成功，通过http://127.0.0.1:3000/ 进行访问');&#125;);/*request请求事件处理函数，需要接受两个参数 Request请求对象 请求对象可以用来获取客户端的一些请求信息，例如请求路径 Response响应对象 响应对象可以用来给客户端发送响应消息*/server.on('request',function(request,response)&#123; console.log('接收到客户端请求,请求路径是：'+ request.url); /*response对象有一个方法：write可以用来给客户端发送响应数据 write可以使用多次，但是最后一定要使用 “end” 来结束响应，否则客户端会一直等待*/ /*response.write('hello '); response.write('this is node.js'); response.end();*/ //上面write的方式比较麻烦，可以直接end的同时发送数据 response.end('hello this is node.js');&#125;); 响应内容只能是二进制数据或者字符串Node中的模块系统 ECMAScript 核心模块 第三方模块 用户自定义模块核心模块Node为JavaScript提供了很多服务器级别的API，这些API绝大多数都被包装到了一个具名的核心模块中。例如： 文件操作的fs核心模块fs核心模块中readFileAPI的第二个参数是可选的，传入utf8可以把读取到的文件直接按照utf8编码转成我们能认识的字符（默认是二进制）,除了这种方法，也可以通过data.toString()方法。 123456fs.readFile('./db.json','utf8',function(err,data)&#123; if(err)&#123; return res.status(500).send('Server error...') &#125; console.log(data)&#125;) http服务构建的http模块 url路径操作模块 path路径操作模块 os操作系统信息模块 。。。 详细见node官方API文档只要是这个模块是一个核心模块，就必须使用require方法来引入。1234567891011//用来获取机器信息的var os = require('os');//用来操作路径的var path = require('path');//获取当前机器的CPU信息console.log(os.cpus());//memory 内存console.log(os.totalmem());//获取一个路径中的扩展名部分//extname extension nameconsole.log(path.extname('D:/a/c/d/c/hellow.txt')); path路径操作模块参考文档：https://nodejs.org/dist/latest-v11.x/docs/api/path.html path.basename 获取一个路径的文件名（默认包含扩展名） path.dirname 获取一个路径中的目录部分 path.extname 获取一个路径中的扩展名部分 path.parse 把一个路径转为对象 root 根路径 dir 目录 base 包含后缀名的文件名 ext 后缀名 name 不包含后缀名的文件名 path.join 当需要进行路径拼接的时候，推荐使用这个方法 path.isAbsolute 判断一个路径是否是绝对路径Node中的其他成员在每个模块中，除了require、exports等模块相关API之外，还有两个特殊成员： __dirname 动态获取 可以用来获取当前文件模块所属目录的绝对路径 __filename 动态获取 可以用来获取当前文件的绝对路径 __dirname和__filename是不受执行node命令所属路径影响的在文件操作中，使用相对路径是不可靠的，因为在Node中文件操作的路径被设计为相对执行node命令所处的终端路径（这不是bug）。所以为了解决这个问题，只需要把相对路径变为绝对路径。我们可以使用__dirname或者__filename来解决这个问题。在拼接路径的过程中，为了避免手动拼接带来的一些低级错误，所以推荐多使用：path.join()来辅助拼接。所以为了尽量避免这个问题，以后再文件操作中使用的相对路径都统一换为动态的绝对路径 补充：模块中的路径标识和这里的路径没关系，不受影响（就是相对于文件模块） 用户自定义模块 require require是用来加载模块的 在Node中，模块有三种： 具名的核心模块，例如：fs,http 用户自己编写的文件模块 相对路径必须加./（不然会当做核心模块）。 可以省略后缀名 在Node中，没有==全局作用域==，只有==模块作用域== 外部访问不到内部 内部也访问不到外部 默认都是封闭的 既然是模块作用域，那如何让模块和模块之间进行通信 有时候我们加载文件模块的目的不是为了简简单单的执行里面的代码，更重要的是使用里面的成员。 require方法的第二个作用：拿到被加载文件模块导出的接口对象 在每个文件模块中都提供了一个对象：exports exports exports默认是一个空对象 我们要做的就是把所有需要被外部访问的成员挂载到这个exports对象中。 如果一个模块需要直接导出某个成员，而非挂载的方式。那我们就需要用到下面这个方法module.exports = &#39;hello&#39;加载和导出的使用规则require加载规则如果想要了解更多底层细节，可以自行参考：《深入浅出Node.js》中的模块系统章节。 语法：var 自定义变量名 = require(&#39;模块&#39;) 核心模块 模块名 第三方模块 模块名 自己写的模块 路径 两个作用： 执行被加载模块中的代码 得到被加载模块中的exports导出的接口对象 优先从缓存加载 这里b.js只被执行了一次优先从缓存加载，由于a中已经加载过b了，所以这里不会重复加载，可以拿到其中的接口对象，但是不会重复执行里面的代码。这样做的目的是为了 避免重复加载， 提高模块加载效率。 判断模块标识 核心模块本质也是文件，已经被编译到二进制文件中了，我们只需要按照名字来加载就可以了。require(&#39;fs&#39;)require(&#39;http&#39;) 第三方模块凡是第三方模块都必须通过npm来下载使用的时候就可以通过require(&#39;包名&#39;)的方式来进行加载就可以使用不可能有任何一个第三方包和核心模块的名字是一样的既不是核心模块，也不是路径形式的模块 模块加载机制：`node_modules/art-template` `node_modules/art-template/package.json文件` `node_modules/art-template/package.json文件中的main属性` `main属性中就记录了art-template的入口模块` `然后加载使用这个第三方包` `实际上最终加载的还是文件` 如果package.json文件不存在或者main指定的入口模块也没有 则node会自动找该目录下的index.js。(index.js会作为默认备选项) 如果以上所有条件都不成立，则会进入上一级目录中的node_modules目录查找，如果上一级也没有，则逐级向上查找，直到磁盘根目录，最后报错`Can not find module xxx`。 一个项目中有且仅有一个node_modules而且是存放在项目的根目录。 自己写的模块 路径形式的模块：./当前目录，不可省略../上一级目录，不可省略/几乎不用，macOS和linux的磁盘根目录d:/a/foo.js/几乎不用 导出exports Node中是模块作用域，默认文件中的所有成员只在当前文件模块中有效 对于希望可以被其他模块访问的成员，我们就需要把这些公开的成员都挂载到exports接口对象中就可以了 导出多个成员（必须在对象中）： 12345678exports.a = 123;exports.b = 'hello';exports.c = function()&#123; console.log('ccc');&#125;exports.d = &#123; foo : 'bar'&#125; 导出单个成员（拿到的就是：函数、字符串、、、）： 123module.exports = function(x,y)&#123; return x + y;&#125; 下面这个方法同样可以导出多个成员，但是需要重新建立与require的引用关系module.exports = { } 在Node中，每个模块内部都有一个自己的module对象，该module对象中有一个成员叫exports，他也是一个对象，也就是说如果你需要对外导出成员，只需要把导出的成员挂载到module.exports上123456var module = &#123; exports: &#123; foo : 'bar' &#125;&#125;module.exports.foo = 'bar'; 谁来require我，谁就得到module.exports默认在代码的最后有一句：return module.exports我们发现，每次导出接口成员的时候都通过module.exports.xxx = xxx的方式很麻烦。所以，Node为了简化我们的操作，专门提供了一个变量exports等于module.exports,所以在return之前还有一句exports = module.exports 原理解析（exports和module.exports的区别）exports是module.exports的一个引用12console.log(exports === module.exports) // =&gt; trueexports.foo = 'bar' // 等价于 module.exports.foo = 'bar' 每个模块中都有一个module对象 module对象中有一个exports对象 我们可以把需要导出的成员都挂载到module.exports接口对象中 也就是：module.exports.xxx = xxx的方式 但是每次都module.exports.xxx = xxx的方式很麻烦。 所以Node为了方便操作，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports的结果为true 所以对于：module.exports.xxx = xxx的方式完全可以替换为exports.xxx = xxx 当一个模块需要导出单个成员的时候，必须使用：module.exports = xxx的方式 因为每个模块最终向外return的是module.exports 而exports只是module.exports的一个引用 所以即便你为exports重新赋值，也不会影响module.exports 但是有一种赋值方式比较特殊：exports = module.exports这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以灵活运用它第三方模块 art-template 必须通过npm来下载才可以使用什么是模块化 文件作用域 通信规则 加载 require 导出CommonJS模块规范在Node中的JavaScript还有一个重要的概念：模块系统。 模块作用域 使用require方法用来加载模块 使用exports接口对象来导出模块中的成员web服务器开发IP地址和端口号 IP地址用来定位计算机 端口号用来定位具体的应用程序 所有需要联网通信的应用程序都会占用一个端口号 端口号的范围从0 - 65536之间 在计算机中有一些默认端口号，最好不要去使用 例如http服务的80 我们在开发过程中使用一些简单好记的就可以了，例如 3000、5000等 可以同时开启多个服务，但一定要确保不同服务占用不同的端口号才可以 说白了，同一个端口号同一时间只能被一个程序占用 Content-Type（响应内容类型） 在服务端默认发送的数据，其实是utf-8编码的内容，但是浏览器并不知道你是utf-8编码的内容。浏览器在不知道服务器响应内容的编码情况下会按照当前操作系统的默认编码去解析。中文操作系统默认是gbk。解决办法就是告诉浏览器我给你发送的内容是什么编码的response.setHeader(&#39;Content-Type&#39;,&#39;text/plain; charset=utf-8&#39;) 12345678910var http = require('http');var server = http.createServer();;server.on('request',function(request,response)&#123; //设置请求头信息，告诉浏览器用utf-8去解析响应内容 response.setHeader('Content-type','text/plain;charset=utf-8'); response.end('hello,世界');&#125;);server.listen(3000,function()&#123; console.log('Server is runing...');&#125;); text/plain：普通文本 text/html：HTML格式的字符串更多请参考[开源中国contentType对照表]请求对象 Request 响应对象 Response在Node中使用模板引擎模板引擎最早就是诞生于服务器领域，后来才发展到了前端 安装 1npm install art-template 在需要使用的文件模块中加载art-template只需要使用require方法加载就可以了：require(&#39;art-template&#39;)参数中的art-template就是你下载的包的名字也就是说你install的名字是什么，则你require中的就是什么 查文档，使用模板引擎的API 统一处理静态资源服务端渲染留言本 （小案例） 处理留言本案例首页数据列表渲染展示 处理留言本案例发表留言功能 路径 设计好的请求路径 #GET直接或查询字符串数据 Node中需要我们手动解析 url.parse() /pinglun?name=jack&amp;message=hello world split(‘?’) name=jack&amp;messgae=hello world split(‘&amp;’) name=jack message=hello world forEach() name=jack.split(‘=’) 0 key 1 value 掌握如何解析请求路径中的查询字符串 url.parse() 如何在Node中实现服务器重定向 setHeader(‘location’) 301 永久重定向 302 临时重定向 浏览器不会记住 npm node package manager node包管理器npm网站https://www.npmjs.com/npm命令行工具只要安装了node就会自动安装npmnpm也有版本这个概念可以通过在命令行中输入：1npm --version 升级npm1npm install --global npm 常用命令npm常用命令参考链接 npm init npm init -y可以跳过向导，快速生成 npm install 一次性把dependencies选项中的依赖全部安装 npm install 包名 只下载 npm i 简写 npm install --save 包名 下载并且保存依赖项（package.json文件中的dependencies选项） npm uninstall 包名 只删除，如果有依赖项依然保存 npm uninstall --save 包名 删除的同时也会把依赖信息去除 npm un -S 包名 npm help 查看使用帮助 npm 命令 --help 查看指定命令的使用帮助 例如：npm uninstall --help解决npm被墙（下载速度慢）问题npm存储包文件的服务器在国外，有时候会被墙，速度很慢，我们需要解决这个问题 安装淘宝的cnpm12// --global 表示安装到全局，而非当前目录npm insatll --global cnpm 接下来安装包的时候把npm替换成cnpm例子：123//还是通过国外npm服务器，速度比较慢npm insatll jquery//使用cnpm会通过淘宝的服务器来下载jquery 如果不想安装cnpm又想使用淘宝的服务器来下载1npm install jquery --registry=https://registry.npm.taobao.org 但是每次手动添加参数很麻烦，所以可以把这个选项添加到配置文件中：12npm config set registry https://registry.npm.taobao.orgnpm config list 可以查看配置信息 通过上述命令的配置，以后下载所有的包都会通过淘宝镜像来下载。 package.json我们建议每一个项目都要有一个package.json文件（包描述文件，就像产品说明书一样）这个文件可以通过npm init的方式来自动初始化出来对于前端开发者来说，最有用的是那个dependencies选项，可以用来帮我们保存第三方包的依赖信息。 建议执行npm install 包名的时候都加上--save这个选项，目的是为了保存依赖信息。 如果你的node_modules删除了也不用担心，我们只需要：npm install就会自动把package,json中的dependencies中所有的依赖项都下载下来package.json和package-lock.jsonnpm5 以前是不会有package-lock.json这个文件的npm5 之后才加入这个文件当你安装包的时候，npm都会生成或者更新package-lock.json文件ExpressExpress官方网站原生的http在某些方面表现不足以应对我们的开发需求，所以我们就需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码高度统一。 第三方web开发框架 高度封装了http模块 更加专注于业务，而非底层细节 知其所以然安装：1npm install --save express hello world1234const express = require('express')const app = express()app.get('/',(req,res) =&gt; res.send('hello world')app.listen(3000,() =&gt; console.log('express app listening on port 3000!')) 基本路由路由 请求方法 请求路径 请求处理函数get：1234//当你以GET方法请求/的时候，执行对应的处理函数app.get('/',function(req,res) &#123; res.send('Hello World!');&#125;); post：1234//当你以POST方法请求/的时候，执行对应的处理函数app.post('/',function(req,res) &#123; res.send('Hello World!');&#125;); 静态服务123456789// /public资源app.use(express.static('public'));// /files资源app.use(express.static('files'));// /public/xxxapp.use('/public'express.static('public'))// /static/xxxapp.use('/static',express.static('public'));app.use('/static',express.static(path.join(__dirname,'public'))); 在Express中配置使用art-template模板引擎github仓库 安装 12npm install --save art-templatenpm install --save express-art-template 配置 1234567var express = require('express'); var app = express(); // 第一个参数用来配置视图的后缀名，这里是art，则你存储在veiws目录中的模板文件必须是xxx.art，我们可以把art改为htmlapp.engine('art',require('express-art-template')); app.set('view options'，&#123; debug：process.env.NODE_ENV！== 'production' &#125;); 配置使用art-template模板引擎第一个参数表示：当渲染以，.art结尾的文件的时候，使用art-template模板引擎express-art-template是专门用来在Express中把art-template整合到Express中虽然外面不需要加载art-template但是也必须安装原因就在于express-art-template依赖了art-template Express为Response响应对象提供了一个方法：renderrender方法默认不可以使用，但是如果配置了模板引擎就可以使用了res.render(&#39;html模板名&#39;,{模板数据})第一个参数不能写路径，默认回去项目中的views目录查找该模板文件也就是说Express有一个约定：开发人员把所有的视图文件都放到views目录中 另外：如果想要修改默认的views目录，则可以使用下面的方法1app.set('views',目录路径) 使用12345678app.get（'/'，function（req，res） &#123; res.render（'index.art'，&#123; user：&#123; name：'aui'， tags：[ 'art'，'template'，'nodejs' ] &#125; &#125;）; &#125;）; 在Express中获取表单GET请求参数Express内置了一个API，可以直接通过req.query来获取1req.query 在Express获取表单POST请求体数据在Express中没有内置获取表单POST请求体的API，所以我们需要借助第三方包：body-parser。 安装： 1npm install --save body-parser 配置： 12345678910111213141516171819var express = require('express')var bodyParser = require('body-parser')var app = express()// parse application/x-www-form-urlencoded/*配置body-parser只要加入了这个配置，则在req请求对象上会多出来一个属性：body也就是说可以直接通过req.body来获取表单POST请求体数据*/app.use(bodyParser.urlencoded(&#123; extended: false &#125;))// parse application/jsonapp.use(bodyParser.json())app.use(function (req, res) &#123; res.setHeader('Content-Type', 'text/plain') res.write('you posted:\n') res.end(JSON.stringify(req.body, null, 2))&#125;) 在Express中配置使用express-session插件 参考文档：https://github.com/expressjs/session 安装 1npm i express-session 配置 12345678//在Express这个框架中，默认不支持Session和Cookie//但是我们可以使用第三方中间件：express-session来解决//该插件会为req请求对象添加一个成员：req.session默认是一个对象app.use(session(&#123; secret: 'keyboard cat', //配置加密字符串，他会在原有加密基础之上和这个字符串拼起来去加密，增加安全性，防止客户端恶意伪造！ resave: false, saveUninitialized: true//无论你是否使用session，都会默认分配一把钥匙。&#125;)) 使用 1234// 添加Session数据req.session.foo = 'bar'// 获取Session数据req.session.foo 提示：默认Session数据时内存存储的，服务器一旦重启就会丢失，真正的生产环境会把Session进行持久化存储。 Express中的路由API路由因为比较多，一般都单独放在一个模块中1234567var express = require('express');//创建路由容器var router = express.Router();//把路由都挂载到router路由容器上router.get('/',function(req,res)&#123;&#125;//把router导出module.exports = router 接下来在入口模块中12345var express = require('express');var router = require('./router');//路由文件var app = express();//把路由容器挂载到app服务中app.use(router); 我们划分模块的目的就是为了增强项目的可维护性，提升开发效率。 中间件 https://expressjs.com/en/guide/using-middleware.html 中间件的本质就是一个请求处理方法，我们把用户从请求到响应的整个过程分发到多个中间件去处理，这样做的目的是提高代码的灵活性，动态可扩展的。 同一个请求所经过的中间件都是同一个请求对象和响应对象应用程序级别中间件万能匹配（不关心任何请求路径和请求方法）： 1234app.use(function(req,res,next)&#123; console.log('Time:',Date.now()) next()&#125;) 仅以/xxx/开头的： 1234app.use('/a',function(req,res,next)&#123; console.log('Time:',Date.now()) next()&#125;) 路由级别中间件get: 123app.get('/',function(req,res)&#123; res.send('Hello World!')&#125;) post:123app.post('/',function(req,res)&#123; res.send('Get a POST request')&#125;) put:123app.put('/user',function(req,res)&#123; res.send('Get a PUT request at /user')&#125;) delete:123app.delete('/user',function(req,res)&#123; res.send('Get a DELETE request at /user')&#125;) 错误处理中间件1234app.use(function(err,req,res,next)&#123; console.error(err.stack) res.status(500).send('Something broke!')&#125;) 内置中间件 express.static() serves static assets such as HTML files, images, and so on. express.json() parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+ express.urlencoded() parses incoming requests with URL-encoded payloads. NOTE: Available with Express 4.16.0+ 第三方中间件 https://expressjs.com/en/resources/middleware.html body-parser session … …增删改查curd案例github项目地址 文件型数据库（锻炼异步编码）起步 初始化 安装依赖 模块处理路由设计请求方法 | 请求路径 | get参数 | post参数 | 备注——– | ——- | ——- | ——- |—-GET | /students | | | 渲染首页GET | /students/new | | | 渲染添加学生页面POST | /students/new | | name,age,gender,hobbies | 处理添加学生请求GET | /students/edit | id | | 渲染编辑页面POST | /students/edit | | id,name,age,gender,hobbies | 处理编辑请求GET | /students/delete | id | | 处理删除请求提取路由模块router.js123456789101112131415161718192021222324252627/*router.js路由模块职责： 处理路由 根据不同的请求方法+请求路径设置具体的请求处理函数模块职责要单一划分模块的目的是为了增强代码的可维护性提高开发效率*/var express = require('express')//1. 创建一个路由容器var router = express.Router()//2. 把路由都挂在到router路由容器中router.get('/students',function(req,res)&#123;&#125;)router.get('/students/new',function(req,res)&#123;&#125;)router.post('/students/new',function(req,res)&#123;&#125;)router.get('/students/edit',function(req,res)&#123;&#125;)router.post('/students/edit',function(req,res)&#123;&#125;)router.get('/students/delete',function(req,res)&#123;&#125;)//3. 把router导出module.exports = router 自己编写的步骤 处理模板 配置开放静态资源 配置模板引擎 简单路由：/students渲染静态页 路由设计 提取路由模块 由于接下来的业务操作都需要处理文件数据，所以我们要封装student.js 先写好student.js文件结构 查询所有学生列表的API find findById save updateById deleteById 实现具体功能 通过路由收到请求 接受请求中的数据（get,post） req.query req.body 通过数据操作API处理数据 根据操作结果给客户端发送响应 业务功能顺序 列表 添加 编辑 删除 MongoDB（芒果数据库）菜鸟教程|MongoDB参考文档 关系型数据库和非关系型数据库表就是关系，或者说表与表之间存在关系 所有的关系型数据库都需要sql语言来操作 所有的关系型数据都在操作之前需要设计表结构 而且数据表还支持约束 唯一的 主键 默认值 非空 非关系型数据库非常的灵活 有的非关系型数据就是key-value键值对 但是MongoDB是长的最像关系型数据库的非关系型数据库 数据库——数据库 数据表——集合（数组） 表记录——文档对象 MongoDB不需要设计表结构 也就是说你可以任意的向里面存数据，没有结构性这个概念MongoDB数据库的基本概念 可以有多个数据库 一个数据库中可以有多个集合（表） 一个集合中可以有多个文档（表记录） 文档结构很灵活，没有任何限制 MongoDB非常灵活，不需要像MySQL一样先创建数据库、表、设计表结构 这里只需要当你需要插入数据的时候，只需要指定往哪个数据库的哪个集合操作就可以了 一切都由MongoDB来自动帮你完成建库建表的事。1234567891011121314&#123; qq:&#123; users:[ &#123;name:'张三1',age:15&#125;, &#123;name:'张三2',age:15&#125;, &#123;name:'张三3',age:15&#125;, &#123;name:'张三4',age:15&#125;, ], products:[], ... &#125; wechat:&#123;&#125; ...&#125; 安装下载MongoDB官网 安装这里不要勾选，其他一路下一步 配置环境变量 鼠标右键选择“计算机”“属性”，会弹出一个框，点击 “高级系统设置”，会弹出一个系统属性，找到环境变量，再点击系统变量里面的Path变量，点击编辑 将MongoDB默认安装路径复制到里面，例如：C:\Program Files\MongoDB\Server\4.0\bin 命令行输入mongod --version出现以下结果就是安装成功。启动和关闭数据库启动：123# mongodb默认使用执行mongod命令所处盘符根目录下的/data/db作为自己的数据存储目录# 所以在第一次执行该命令之前手动新建/data/db目录mongod 如果想要修改默认的数据存储目录，可以：1mongod --dbpath=数据存储目录路径 停止：12在开启服务的控制台，直接Ctrl+c即可停止或者直接关闭控制台 连接和退出数据库连接：12# 该命令默认连接本机的MongoDB服务mongo 退出：12# 在连接状态输入exit退出连接exit 基本命令 查看显示所有数据库 1show dbs 切换到指定的数据库（没有就会创建） 1use 数据库名称 查看当前操作的数据库 1db 查看当前数据库所有的集合 1show collections 插入数据 1db.students.insertOne(&#123;"name":"Jack"&#125;) 查询数据 12# 查询所有students的数据db.students.find() 在Node中如何操作MongoDB数据使用官方的mongodb包来操作MongoDB官方驱动包 使用第三方mongoose操作MongoDB数据库第三方包：mongoose基于MongoDB官方的mongodb包再一次做了封装mongoose官网mongoose官方API文档 起步1npm i mongoose hello world1234567const mongoose = require('mongoose');mongoose.connect('mongodb://localhost:27017/test', &#123;useNewUrlParser: true&#125;);const Cat = mongoose.model('Cat', &#123; name: String &#125;);const kitty = new Cat(&#123; name: 'Zildjian' &#125;);kitty.save().then(() =&gt; console.log('meow')); 官方指南 设计Schema发布Model 1234567891011121314151617181920212223242526272829303132333435var mongoose = require('mongoose');var Schema = mongoose.Schema;//1. 连接数据库，指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来mongoose.connect('mongodb://localhost/demo1');/*2. 设计文档结构（表结构）字段名称就是表结构中的属性名称约束的目的就是为了保证数据的完整性，不要有脏数据*/var userSchema = new Schema(&#123; username: &#123; type:String, required: true//必须有 &#125;, password: &#123; type: String, required: true &#125;, email: &#123; type: String &#125;&#125;);/*3. 将文档结构发布为模型 mongoose.model方法就是将一个架构发布为model 第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称 mongoose会自动将大写名词的字符串生成小写复数的集合名称 例如这里的User最终会变为users集合名称 第二个参数：Schema 返回值： 模型构造函数*/ var User = mongoose.model('User',userSchema);/*4. 当我们有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据为所欲为了(增删改查)*/ 增加数据 12345678910111213var admin = new User(&#123; username: 'admin', password: '123456', email: 'admin@admin.com'&#125;);admin.save(function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else&#123; console.log('ok') console.log(ret) &#125;&#125;); 查询数据 123456789101112131415161718 // 查询User.find(/*&#123;name: 'admin'&#125;,查找所有符合条件的，不加就是查询所有*/function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else &#123; console.log(ret) &#125;&#125;)// 按条件查询单个数据User.findOne(&#123; username: 'admin', password: '123456'&#125;,function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else &#123; console.log(ret) &#125;&#125;) 删除数据 123456789User.remove(&#123; username: 'admin'&#125;,function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else &#123; console.log('ok') &#125;&#125;); 更新数据 1234567891011121314// 根据条件更新所有：Model.update(conditiions,doc,[options],[callback]);// 根据指定条件更新一个：Model.findOneAndUpdate([conditions],[update],[options],[callback]);// 根据id更新一个User.findByIdAndUpdate('50dfd4535500df00554gf',&#123; password: '123'&#125;,function(err,ret)&#123; if(err)&#123; console.log('err') &#125; else &#123; console.log('ok') &#125;&#125;) 其他修改完代码自动重启服务器我们这里可以使用一个第三方工具：nodemon来帮我们解决频繁修改代码重启服务器的问题。nodemon是一个基于Node.js开发的一个第三方命令行工具，我们使用的时候需要独立安装：1npm install --global nodemon 安装完毕之后，使用：123不用再使用node xx.js命令使用nodemonnodemon xxx.js 只要是通过nodemon启动的服务，它会监视你的文件变化，当文件发生变化，会自动重启服务器。 文件操作路径和模块路径文件操作路径：1234567891011121314/*在文件操作的相对路径中 ./data/a.txt 相对于当前目录 data/a.txt 相对于当前目录 /data/a.txt 绝对路径，当前文件模块所处磁盘根目录 c:/xx/xxx... 绝对路径 fs.readFile('./data/a.txt',function(err,data)&#123; if(err)&#123; console.log(err) return console.log('读取失败') &#125; console.log(data.toString)()) &#125;)*/ 模块操作路径：12345//这里如果忽略了，则也是磁盘根目录require('/data/foo.js')//相对路径require('.data/foo.js')//模块加载的路径中的相对路径不能省略 ./ 注：Node不适合从来没有接触过服务端的人学习如果想要真正的学好服务端，还是老牌的java、PHP这些平台node不是特别适合入门服务端，但不代表node不强大node很厉害，具有经验的人可以玩的非常牛不适合新手的原因就是在于偏底层、而且太灵活java、PHP好入门的原因就在于：这些平台屏蔽了一些底层]]></content>
  </entry>
  <entry>
    <title><![CDATA[Git和GitHub的基本使用]]></title>
    <url>%2F2018%2F03%2F17%2FGit%E5%92%8CGitHub%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[GIT什么是Git 是一个源代码管理工具 在一个项目中，凡是由开发人员编写的都算是源代码 让源代码可以被追溯，主要记录每次变更了什么。 人为维护比较麻烦 Git是Linux之父为了维护管理Linux的源代码写的一个工具 Git 之前很多实用SVN vss tfs hs 。。。 安装Git Git命令行工具 基于Git命令行的一个客户端软件（提供一个界面去管理源代码） Git命令操作初始化一个本地Git仓储12cd 当前项目目录git init // 初始化一个本地仓库 就是在本地文件夹中添加了一个.git的文件夹用于记录项目的变更信息 查看本地仓储的变更状态 git status 第一次查看，显示的是一坨没有被跟踪的变化 git status -s 列出更详细的信息 添加本地暂存（托管）文件1git add 可以将一个没有被跟踪的文件添加到跟踪列表 类似于node_modules这种性质的文件是不应该被跟踪的 添加本地忽略清单 在代码库文件夹的根目录添加一个.gitignore文件 此文件用于说明忽略的文件有哪些 由于Windows下不知直接建以” . “开头的文件，必须键入文件名才可以，所以应该使用命令行创建上面这个文件夹 123echo '' &gt; .gitignore//下面这种是文件夹格式的mkdir .gitignore 里面写上文件名即可（支持通配符） /dist: 表示根目录下dist被禁止。 提交被托管的文件变化到本地仓储12git commit -m '第一次提交'//将本地的变化提交到本地的仓库文件夹归档 后面需要加上 -m ‘信息（如第一次提交或者修改了什么文件，第二次提交）’ 一般在有了一个小单元的整体变化后再提交 对比差异1git diff //difference差异 查看提交日志1git log ### 回归到指定版本1 git reset --hard //后面跟上对应版本的哈希值前六位 查看所有命令1git help GitHub基本使用 https://github.com/ GitHub是一个git服务的提供商 提出了社交化编程 添加一个远端的地址12git remote add origin 远端地址git remote -v //查看地址 推送到远端123git push -u origin master//-u是以流的方式上传，速度比较快，可以不加。//master是主分支 从远端拉回1git pull origin master 分支 查看当前分支 1git branch 创建一个分支 1git branch v2(分支名) 切换分支 1git checkout v2 创建分支之后需要继续推到远端仓库git push -u origin v2 特殊的分支（网页预览）12git branch gh-pages//名字必须为gh-pages才可变成网页 如果需要绑定域名需要在对应仓库下建立CNAME文件，里面写上域名。前提是需要做dns解析!克隆仓库1git clone 远端地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式（笔记）]]></title>
    <url>%2F2018%2F01%2F17%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E7%AC%94%E8%AE%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[RegExpw3school: http://www.w3school.com.cn/js/jsref_obj_regexp.asp 正则表达式的作用： 匹配特殊字符或有特殊搭配原则的字符串的最佳选择。 两种创建方式 推荐使用 1var reg = /abc/; 例：123var reg = /abc/i //i ignoreCase 忽视大小写var reg = /abc/m //m 执行多行匹配var reg = /abc/ g // g global 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） new RegExp( ) 1var reg = new RegExp() 正则表达式方法 compile : 编译正则表达式。 exec : 检索字符串中指定的值。返回找到的值，并确定其位置。 test : 检索字符串中指定的值。返回 true 或 false。支持正则的字符串方法 search ： 检索与正则表达式相匹配的值。 match : 找到一个或多个正则表达式的匹配 replace：替换与正则表达式匹配的子符串。 split：把字符串分割为字符串数组方括号（摘自w3school）元字符（摘自w3school）量词（摘自w3school）例题1234var str = "100000000";var reg = /(?=(\B)(\d&#123;3&#125;)+$)/g;console.log(str.replace(reg,"."));//输出结果为：100.000.000]]></content>
  </entry>
</search>
